FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:21
Called 7 times
Total time:   0.040640
 Self time:   0.000774

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    7   0.008528   0.000140   if gitgutter#utility#is_active(a:bufnr)
                            
    7              0.000106     if has('patch-7.4.1559')
    7              0.000120       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    7              0.000012     endif
    7   0.031624   0.000146     let how = s:setup_path(a:bufnr, l:Callback)
    7              0.000071     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    7              0.000010       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>127_on_stderr_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:83
Called 7 times
Total time:   0.000634
 Self time:   0.000124

count  total (s)   self (s)
    7   0.000623   0.000113   call self.handler.err(self.buffer)

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 7 times
Total time:   0.000387
 Self time:   0.000196

count  total (s)   self (s)
    7   0.000339   0.000148   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    7              0.000041   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:367
Called 2 times
Total time:   0.001810
 Self time:   0.001213

count  total (s)   self (s)
    2              0.000008     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    4              0.000029     for l:original_filetype in split(a:original_filetypes, '\.')
    2   0.000232   0.000025         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    2   0.000225   0.000024         let l:linter_names = s:GetLinterNames(l:original_filetype)
    2   0.000210   0.000021         let l:all_linters = ale#linter#GetAll(l:filetype)
    2              0.000005         let l:filetype_linters = []
                            
    2              0.000010         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
    2              0.000007         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
   30              0.000049             for l:linter in l:all_linters
   28              0.000138                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
   48              0.000085                 for l:name in l:name_list
   28              0.000100                     if index(l:linter_names, l:name) >= 0
    8              0.000031                         call add(l:filetype_linters, l:linter)
    8              0.000008                         break
   20              0.000020                     endif
   48              0.000044                 endfor
   30              0.000028             endfor
    2              0.000018         endif
                            
    2              0.000011         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    4              0.000010     endfor
                            
    2              0.000006     let l:name_list = []
    2              0.000005     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   10              0.000020     for l:linter in reverse(l:possibly_duplicated_linters)
    8              0.000031         if index(l:name_list, l:linter.name) < 0
    8              0.000029             call add(l:name_list, l:linter.name)
    8              0.000025             call add(l:combined_linters, l:linter)
    8              0.000008         endif
   10              0.000010     endfor
                            
    2              0.000007     return reverse(l:combined_linters)

FUNCTION  <SNR>96_GetLinterNames()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:330
Called 2 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    2              0.000012     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    2              0.000006     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    2              0.000002     endif
                            
                                " b:ale_linters can be set to a List.
    2              0.000007     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    2              0.000002     endif
                            
                                " Try to get a buffer-local setting for the filetype
    2              0.000008     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    2              0.000002     endif
                            
                                " Try to get a global setting for the filetype
    2              0.000103     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    2              0.000002     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    2              0.000006     if g:ale_linters_explicit
                                    return []
    2              0.000002     endif
                            
                                " Try to get a default setting for the filetype
    2              0.000010     if has_key(s:default_ale_linters, a:original_filetype)
    2              0.000007         return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  <SNR>117_HasAnyKey()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:471
Called 12 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
   24              0.000089   for key in a:keys
   12              0.000050     if has_key( a:dict, key )
                                  return 1
   12              0.000014     endif
   24              0.000039   endfor
   12              0.000019   return 0

FUNCTION  <SNR>117_InsideCommentOrString()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:932
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
    1              0.000008   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
    1              0.000003   if stridx(syntax_group, 'Comment') > -1
                                return 1
    1              0.000001   endif
                            
    1              0.000002   if stridx(syntax_group, 'String') > -1
                                return 2
    1              0.000001   endif
                            
    1              0.000001   return 0

FUNCTION  <SNR>126_highlight_range()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:122
Called 1 time
Total time:   0.000036
 Self time:   0.000014

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
    1   0.000036   0.000014     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>113_FormatFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:156
Called 4 times
Total time:   0.000142
 Self time:   0.000082

count  total (s)   self (s)
    4              0.000008     let l:filename = a:filename
                            
    4              0.000009     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
    4              0.000004     endif
                            
    4              0.000008     if !empty(a:modifiers)
    2              0.000009         let l:filename = fnamemodify(l:filename, a:modifiers)
    4              0.000004     endif
                            
    4   0.000081   0.000021     return ale#Escape(l:filename)

FUNCTION  <SNR>117_Hover()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1363
Called 6 times
Total time:   0.019835
 Self time:   0.004793

count  total (s)   self (s)
    6              0.004103     if !py3eval( 'ycm_state.NativeFiletypeCompletionUsable()' )
                                  " Cancel the autocommand if it happens to have been set
                                  call s:DisableAutoHover()
                                  return
    6              0.000016     endif
                            
    6              0.000059     if !has_key( b:, 'ycm_hover' )
                                  let cmds = youcompleteme#GetDefinedSubcommands()
                                  if index( cmds, 'GetHover' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetHover', 'syntax': 'markdown', }
                                  elseif index( cmds, 'GetDoc' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetDoc', 'syntax': '', }
                                  elseif index( cmds, 'GetType' ) >= 0
                                    let b:ycm_hover = { 'command': 'GetType', 'syntax': &syntax, }
                                  else
                                    let b:ycm_hover = {}
                                  endif
    6              0.000004     endif
                            
    6              0.000027     if empty( b:ycm_hover )
                                  return
    6              0.000007     endif
                            
    6   0.015352   0.000310     call youcompleteme#GetCommandResponseAsync( function( 's:ShowHoverResult' ), b:ycm_hover.command )

FUNCTION  <SNR>68_unc_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 7 times
Total time:   0.001512
 Self time:   0.000165

count  total (s)   self (s)
    7   0.001507   0.000160   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>117_RequestSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1075
Called 1 time
Total time:   0.000500
 Self time:   0.000422

count  total (s)   self (s)
    1   0.000015   0.000005   if !s:ShouldUseSignatureHelp()
                                return
    1              0.000001   endif
                            
    1   0.000010   0.000006   call s:StopPoller( s:pollers.signature_help )
                            
    1              0.000399   if py3eval( 'ycm_state.SendSignatureHelpRequest()' )
    1   0.000073   0.000009     call s:PollSignatureHelp()
    1              0.000000   endif

FUNCTION  xolox#notes#filetype_is_note()
    Defined: ~/.vim/bundle/vim-notes/autoload/xolox/notes.vim:644
Called 9 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
                              " Check whether the given file type value refers to the notes.vim plug-in.
    9              0.000383   return index(split(a:ft, '\.'), 'notes') >= 0

FUNCTION  <SNR>114_VimOutputCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:68
Called 1 time
Total time:   0.000043
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000004     let l:job = ch_getjob(a:channel)
    1   0.000017   0.000009     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
    1              0.000003     if l:job_id > 0 && has_key(s:job_map, l:job_id)
    1   0.000019   0.000011         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
    1              0.000000     endif

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:72
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000002     if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
    2              0.000000     else
    3              0.000006         for l:match in getmatches()
    1              0.000005             if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
    1              0.000002                 call matchdelete(l:match.id)
    1              0.000001             endif
    3              0.000002         endfor
    2              0.000000     endif

FUNCTION  ale#command#CdString()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:173
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000023     let l:match = matchstrpos(a:directory, s:path_format_regex)
                                " Do not escape the directory here if it's a valid format string.
                                " This allows us to use sequences like %s:h, %s:h:h, etc.
    2              0.000017     let l:directory = l:match[1:] == [0, len(a:directory)]   ? a:directory   : ale#Escape(a:directory)
                            
    2              0.000005     if has('win32')
                                    return 'cd /d ' . l:directory . ' && '
    2              0.000002     endif
                            
    2              0.000006     return 'cd ' . l:directory . ' && '

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:231
Called 2 times
Total time:   0.000244
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000064   0.000010     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    2   0.000179   0.000009     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:50
Called 2 times
Total time:   0.000042
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000031   0.000011     call ale#command#InitData(a:buffer)
    2              0.000010     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <SNR>113_GatherOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:281
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000013     call add(a:line_list, a:line)

FUNCTION  <SNR>88_cache()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:175
Called 2 times
Total time:   0.074795
 Self time:   0.052077

count  total (s)   self (s)
    2              0.000027     let cache = [{}]  " With padding for lnum offset
    2              0.000143     let lines = getbufline(bufnr('%'), 1, '$')
    2              0.000014     let lnum_last = len(lines)
    2              0.000021     call insert(lines, '')  " Padding for lnum offset
                            
    2   0.000072   0.000033     let ind_spaces = s:indent_spaces()
                            
    2              0.000005     let defs_stack = []
    2              0.000004     let ind_def = -1
    2              0.000005     let in_string = 0
    2              0.000005     let docstring_start = -1
    2              0.000004     let in_import = 0
    2              0.000004     let was_import = 0
  269              0.000419     for lnum in range(1, lnum_last)
  267              0.000707         let line = lines[lnum]
                            
                                    " Multiline strings
  267              0.000339         if in_string
   62              0.000178             let foldlevel = len(defs_stack)
   62              0.000368             call add(cache, {'is_blank': 0, 'is_comment': 0, 'foldexpr': foldlevel})
                            
   62   0.003946   0.000722             let string_match = s:multi_string(line, string_end_re, 1)
   62              0.000130             if string_match[0]
                                            " Starting new multiline string?
   42              0.000075                 if string_match[2]
                                                let in_string_single = string_match[1]
                                                let string_end_re = string_match[3]
                                                let docstring_start = -1  " Invalid docstring
   42              0.000097                 elseif in_string_single && line !~# s:line_cont_re
                                                let in_string = 0
   42              0.000044                 endif
   20              0.000018             else
   20              0.000036                 if docstring_start != -1
   10              0.000021                     let foldlevel += 1
   10              0.000048                     let cache[docstring_start]['foldexpr'] = '>' . foldlevel
   46              0.000112                     for lnum_docstring in range((docstring_start + 1), lnum)
   36              0.000118                         let cache[lnum_docstring]['foldexpr'] = foldlevel
   46              0.000055                     endfor
   10              0.000020                     let docstring_start = -1
   20              0.000020                 endif
   20              0.000033                 let in_string = 0
   62              0.000052             endif
   62              0.000064             continue
  205              0.000187         endif
                            
                                    " Blank lines
  205              0.001219         if line =~# s:blank_re
   43              0.000083             if lnum == lnum_last
                                            call add(cache, {'is_blank': 1, 'is_comment': 0, 'foldexpr': 0})
                                            call s:blanks_adj(cache, lnum, 0)
   43              0.000047             else
   43              0.000303                 call add(cache, {'is_blank': 1, 'is_comment': 0, 'foldexpr': len(defs_stack)})
   43              0.000046             endif
   43              0.000057             continue
  162              0.000142         endif
                            
  162   0.005944   0.001295         let ind = s:indent(line, ind_spaces)
                            
                                    " Comments
  162              0.000799         if line =~# s:comment_re
    6              0.000032             call add(cache, {'is_blank': 0, 'is_comment': 1, 'indent': ind})
    6              0.000009             let foldlevel = 0
    6              0.000018             let defs_stack_len = len(defs_stack)
    6              0.000024             for idx in range(defs_stack_len)
    6              0.000026                 if ind > cache[defs_stack[idx]]['indent']
    6              0.000013                     let foldlevel = defs_stack_len - idx
    6              0.000006                     break
                                            endif
    6              0.000009             endfor
    6              0.000019             let cache[lnum]['foldexpr'] = foldlevel
    6   0.000246   0.000052             call s:blanks_adj(cache, lnum, foldlevel)
    6              0.000006             continue
  156              0.000140         endif
                            
  156              0.003857         call add(cache, {'is_blank': 0, 'is_comment': 0,            'is_def': line =~# b:SimpylFold_def_re, 'indent': ind})
                            
                                    " Definitions
  156              0.000458         if cache[lnum]['is_def']
   14              0.000033             if empty(defs_stack)
    2              0.000005                 let defs_stack = [lnum]
   12              0.000017             elseif ind == ind_def
   12              0.000034                 let defs_stack[0] = lnum
                                        elseif ind > ind_def
                                            call insert(defs_stack, lnum)
                                        elseif ind < ind_def
                                            let defs_stack = [lnum] + s:defs_stack_prune(cache, defs_stack, ind)
   14              0.000015             endif
   14              0.000043             let foldlevel = len(defs_stack) - 1
   14              0.000026             let ind_def = ind
   14   0.000836   0.000130             call s:blanks_adj(cache, lnum, foldlevel)
   14              0.000071             let cache[lnum]['foldexpr'] = '>' . (foldlevel + 1)
   14              0.000016             continue
  142              0.000131         endif
                            
                                    " Everything else
  142              0.000354         if !empty(defs_stack)
  138              0.000197             if ind == ind_def
                                            let defs_stack = defs_stack[1:]
                                            let ind_def = cache[defs_stack[0]]['indent']
  138              0.000233             elseif ind < ind_def
                                            let defs_stack = s:defs_stack_prune(cache, defs_stack, ind)
                                            if !empty(defs_stack)
                                                let ind_def = cache[defs_stack[0]]['indent']
                                            else
                                                let ind_def = -1
                                            endif
  138              0.000114             endif
  142              0.000129         endif
  142              0.000396         let foldlevel = len(defs_stack)
                            
                                    " Multiline strings start
  142   0.012676   0.001688         let string_match = s:multi_string(line, s:string_start_re, 0)
  142              0.000289         if string_match[0]
   20              0.000035             let in_string = 1
   20              0.000058             let in_string_single = string_match[1]
   20              0.000060             let string_end_re = string_match[3]
                            
                                        " Docstrings
   20              0.000160             if b:SimpylFold_fold_docstring && !string_match[2] && string_match[4] =~# s:blank_re
   10              0.000027                 let lnum_prev = lnum - 1
   10   0.000331   0.000194                 if lnum == 1 || s:are_lines_prev_blank(cache, lnum) || ( !cache[lnum_prev]['is_blank'] && !cache[lnum_prev]['is_comment'] && ( cache[lnum_prev]['is_def'] || lines[lnum_prev] =~# s:multi_def_end_re ) )
   10              0.000023                     let docstring_start = lnum
   10              0.000012                 endif
   20              0.000016             endif
                            
   20              0.000068             let cache[lnum]['foldexpr'] = foldlevel
   20              0.000023             continue
  122              0.000111         endif
                            
                                    " Imports
  122              0.000267         if b:SimpylFold_fold_import
  122              0.000152             if in_import
                                            if line =~# import_end_re
                                                let in_import = 0
                                            endif
                            
                                            call s:blanks_adj(cache, lnum, foldlevel + 1)
                                            let cache[lnum]['foldexpr'] = foldlevel + 1
                                            continue
  122              0.001419             elseif match(line, s:import_start_re) != -1
    4              0.000113                 let import_cont_match = matchlist(line, s:import_cont_re)
    4              0.000015                 if !empty(import_cont_match)
                                                if import_cont_match[1] ==# '('
                                                    let import_end_re = s:import_end_paren_re
                                                    let in_import = 1
                                                elseif import_cont_match[2] ==# '\'
                                                    let import_end_re = s:import_end_esc_re
                                                    let in_import = 1
                                                endif
    4              0.000004                 endif
                            
    4              0.000007                 if was_import
    2   0.000121   0.000053                     call s:blanks_adj(cache, lnum, foldlevel + 1)
    2              0.000010                     let cache[lnum]['foldexpr'] = foldlevel + 1
    2              0.000003                 else
    2              0.000040                     let cache[lnum]['foldexpr'] = '>' . (foldlevel + 1)
    4              0.000004                 endif
    4              0.000009                 let was_import = 1
    4              0.000006                 continue
  118              0.000103             else
  118              0.000209                 let was_import = 0
  118              0.000102             endif
  118              0.000098         endif
                            
                                    " Normal
  118   0.003734   0.001021         call s:blanks_adj(cache, lnum, foldlevel)
  118              0.000395         let cache[lnum]['foldexpr'] = foldlevel
  120              0.000162     endfor
                            
    2              0.000002     return cache

FUNCTION  youcompleteme#GetCommandResponseAsync()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1240
Called 6 times
Total time:   0.015042
 Self time:   0.013775

count  total (s)   self (s)
    6   0.001404   0.000137   if !s:AllowedToCompleteInCurrentBuffer()
                                eval a:callback( '' )
                                return
    6              0.000007   endif
                            
    6              0.000028   if !get( b:, 'ycm_completing' )
                                eval a:callback( '' )
                                return
    6              0.000006   endif
                            
    6              0.000019   if s:pollers.command.id != -1
                                eval a:callback( '' )
                                return
    6              0.000005   endif
                            
    6              0.013284   py3 ycm_state.SendCommandRequestAsync( vim.eval( "a:000" ) )
                            
    6              0.000172   let s:pollers.command.id = timer_start( s:pollers.command.wait_milliseconds, function( 's:PollCommand', [ 'StringResponse', a:callback ] ) )

FUNCTION  <SNR>94_Lint()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:99
Called 2 times
Total time:   0.008555
 Self time:   0.000471

count  total (s)   self (s)
                                " Use the filetype from the buffer
    2              0.000031     let l:filetype = getbufvar(a:buffer, '&filetype')
    2   0.001859   0.000049     let l:linters = ale#linter#Get(l:filetype)
    2   0.000164   0.000037     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    2              0.000007     let g:ale_want_results_buffer = a:buffer
    2   0.000259   0.000218     silent doautocmd <nomodeline> User ALEWantResults
    2              0.000007     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    2              0.000015     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    2              0.000002     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    2              0.000017     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    2   0.006164   0.000058     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 7 times
Total time:   0.030412
 Self time:   0.001285

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    7   0.000441   0.000131   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    7   0.006074   0.000381   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    7   0.000288   0.000230   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    7              0.000065     let handler = copy(s:set_path_handler)
    7              0.000035     let handler.continuation = a:continuation
    7   0.023376   0.000310     call gitgutter#async#execute(cmd, a:bufnr, handler)
    7              0.000023     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:120
Called 1 time
Total time:   0.000029
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
    2              0.000001     for l:item in a:sublist
    1   0.000013   0.000004         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    1              0.000001         if l:item_priority > l:priority
    1              0.000001             let l:priority = l:item_priority
    1              0.000000         endif
    2              0.000002     endfor
                            
    1              0.000001     if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
    1              0.000000     endif
                            
    1              0.000001     if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
    1              0.000000     endif
                            
    1              0.000001     if l:priority is# g:ale#util#style_error_priority
    1              0.000001         return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>117_OnCursorMovedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:809
Called 3 times
Total time:   0.001478
 Self time:   0.000822

count  total (s)   self (s)
    3   0.000708   0.000052   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    3              0.000004   endif
                            
    3              0.000745   py3 ycm_state.OnCursorMoved()

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:269
Called 4 times
Total time:   0.000112
 Self time:   0.000075

count  total (s)   self (s)
    4   0.000058   0.000021     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
    4              0.000010     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
    4              0.000002     endif
                            
    4              0.000005     let l:name = a:name
                            
    4              0.000009     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
    4              0.000003         let l:name = '*'
    4              0.000002     endif
                            
    4              0.000010     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:136
Called 2 times
Total time:   0.000155
 Self time:   0.000092

count  total (s)   self (s)
    2              0.000006     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    2   0.000035   0.000008     call ale#highlight#RemoveHighlights()
                            
    3              0.000003     for l:item in l:item_list
    1              0.000001         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
    1              0.000001         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
    1              0.000002         elseif get(l:item, 'sub_type', '') is# 'style'
    1              0.000001             let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
    1              0.000000         endif
                            
    1              0.000005         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
    1   0.000041   0.000005         call s:highlight_range(l:item.bufnr, l:range, l:group)
    3              0.000003     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    2              0.000002     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    2              0.000000     endif

FUNCTION  <SNR>96_GetAliasedFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:294
Called 2 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    2              0.000015     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    2              0.000018     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    2              0.000002     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    8              0.000037     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    6              0.000026         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    6              0.000006         endif
    8              0.000009     endfor
                            
    2              0.000004     return a:original_filetype

FUNCTION  <SNR>117_PollSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1088
Called 2 times
Total time:   0.000511
 Self time:   0.000318

count  total (s)   self (s)
    2   0.000157   0.000031   if !s:ShouldUseSignatureHelp()
                                return
    2              0.000001   endif
                            
    2              0.000008   if a:0 == 0 && s:pollers.signature_help.id >= 0
                                " OK this is a bug. We have tried to poll for a response while the timer is
                                " already running. Just return and wait for the timer to fire.
                                return
    2              0.000000   endif
                            
    2              0.000052   if !py3eval( 'ycm_state.SignatureHelpRequestReady()' )
    1              0.000009     let s:pollers.signature_help.id = timer_start( s:pollers.signature_help.wait_milliseconds, function( 's:PollSignatureHelp' ) )
    1              0.000001     return
    1              0.000001   endif
                            
    1              0.000174   let s:signature_help = py3eval( 'ycm_state.GetSignatureHelpResponse()' )
    1   0.000088   0.000021   call s:UpdateSignatureHelp()

FUNCTION  <SNR>88_indent()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:49
Called 162 times
Total time:   0.004649
 Self time:   0.004649

count  total (s)   self (s)
  162              0.001208     let ind = matchend(a:line, '^ *') / a:ind_spaces
  162              0.000268     if ind == 0
   18              0.000137         let ind = matchend(a:line, '^\t*')
  162              0.000155     endif
                                " Fix indent for solo def multiline endings
  162              0.001630     if a:line =~# s:multi_def_end_solo_re
                                    return ind + 1
  162              0.000151     endif
  162              0.000214     return ind

FUNCTION  <SNR>117_OnInsertLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:883
Called 1 time
Total time:   0.003265
 Self time:   0.000722

count  total (s)   self (s)
    1   0.000174   0.000013   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000000   endif
                            
    1              0.000003   let s:last_char_inserted_by_user = v:false
                            
    1   0.000020   0.000011   call s:StopPoller( s:pollers.completion )
    1              0.000003   let s:force_semantic = 0
    1              0.000009   let s:completion = s:default_completion
                            
    1   0.002133   0.000008   call s:OnFileReadyToParse()
    1              0.000608   py3 ycm_state.OnInsertLeave()
    1              0.000007   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
    1   0.000054   0.000033     call s:ClosePreviewWindowIfNeeded()
    1              0.000001   endif
                            
    1   0.000236   0.000009   call s:ClearSignatureHelp()

FUNCTION  ale_linters#python#flake8#Handle()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:90
Called 2 times
Total time:   0.000243
 Self time:   0.000127

count  total (s)   self (s)
    2   0.000039   0.000010     let l:output = ale#python#HandleTraceback(a:lines, 10)
                            
    2              0.000002     if !empty(l:output)
                                    return l:output
    2              0.000000     endif
                            
                                " Matches patterns line the following:
                                "
                                " Matches patterns line the following:
                                "
                                " stdin:6:6: E111 indentation is not a multiple of four
    2              0.000002     let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):?(\d+)?: ([[:alnum:]]+):? (.*)$'
                            
    3   0.000096   0.000009     for l:match in ale#util#GetMatches(a:lines, l:pattern)
    1              0.000002         let l:code = l:match[3]
                            
    1              0.000002         if (l:code is# 'W291' || l:code is# 'W293') && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                        " Skip warnings for trailing whitespace if the option is off.
                                        continue
    1              0.000000         endif
                            
    1              0.000001         if l:code is# 'W391'&& !ale#Var(a:buffer, 'warn_about_trailing_blank_lines')
                                        " Skip warnings for trailing blank lines if the option is off
                                        continue
    1              0.000001         endif
                            
    1              0.000004         let l:item = {   'lnum': l:match[1] + 0,   'col': l:match[2] + 0,   'vcol': 1,   'text': l:match[4],   'code': l:code,   'type': 'W',}
                            
    1              0.000001         if l:code[:0] is# 'F'
                                        if l:code isnot# 'F401'
                                            let l:item.type = 'E'
                                        endif
    1              0.000001         elseif l:code[:0] is# 'E'
    1              0.000001             let l:item.type = 'E'
                            
    1              0.000002             if l:code isnot# 'E999' && l:code isnot# 'E112'
    1              0.000001                 let l:item.sub_type = 'style'
    1              0.000000             endif
                                    elseif l:code[:0] is# 'W'
                                        let l:item.sub_type = 'style'
    1              0.000000         endif
                            
    1              0.000003         let l:end_col_pattern = get(s:end_col_pattern_map, l:code, '')
                            
    1              0.000002         if !empty(l:end_col_pattern)
                                        let l:end_col_match = matchlist(l:match[4], l:end_col_pattern)
                            
                                        if !empty(l:end_col_match)
                                            let l:item.end_col = l:item.col + len(l:end_col_match[1]) - 1
                                        endif
    1              0.000001         endif
                            
    1              0.000001         call add(l:output, l:item)
    3              0.000006     endfor
                            
    2              0.000001     return l:output

FUNCTION  ale#job#Start()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:215
Called 4 times
Total time:   0.005746
 Self time:   0.005615

count  total (s)   self (s)
    4   0.000066   0.000038     call ale#job#ValidateArguments(a:command, a:options)
                            
    4              0.000019     let l:job_info = copy(a:options)
    4              0.000009     let l:job_options = {}
                            
    4              0.000019     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
    4              0.000004     else
    4              0.000026         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
    4              0.000012         if has_key(a:options, 'out_cb')
    4              0.000033             let l:job_options.out_cb = function('s:VimOutputCallback')
    4              0.000004         endif
                            
    4              0.000012         if has_key(a:options, 'err_cb')
    2              0.000012             let l:job_options.err_cb = function('s:VimErrorCallback')
    4              0.000004         endif
                            
    4              0.000011         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
    4              0.000023             let l:job_options.close_cb = function('s:VimCloseCallback')
    4              0.000022             let l:job_options.exit_cb = function('s:VimExitCallback')
    4              0.000004         endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
    4              0.000018         if has('patch-8.1.350')
    4              0.000008             let l:job_options.noblock = 1
    4              0.000004         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
    4              0.004846         let l:job_info.job = job_start(a:command, l:job_options)
    4   0.000333   0.000230         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    4              0.000005     endif
                            
    4              0.000009     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    4              0.000042         let s:job_map[l:job_id] = l:job_info
    4              0.000004     endif
                            
    4              0.000012     return l:job_id

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:34
Called 6 times
Total time:   0.000097
 Self time:   0.000053

count  total (s)   self (s)
    6   0.000073   0.000029     call ale#command#InitData(a:buffer)
    6              0.000019     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  ale_linters#python#flake8#GetCommand()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:62
Called 2 times
Total time:   0.006902
 Self time:   0.000102

count  total (s)   self (s)
    2   0.006740   0.000025     let l:executable = ale_linters#python#flake8#GetExecutable(a:buffer)
                            
    2              0.000015     let l:exec_args = l:executable =~? 'pipenv$'   ? ' run flake8'   : ''
                            
                                " Only include the --stdin-display-name argument if we can parse the
                                " flake8 version, and it is recent enough to support it.
    2   0.000047   0.000019     let l:display_name_args = ale#semver#GTE(a:version, [3, 0, 0])   ? ' --stdin-display-name %s'   : ''
                            
    2   0.000035   0.000012     let l:options = ale#Var(a:buffer, 'python_flake8_options')
                            
    2   0.000058   0.000024     return ale#Escape(l:executable) . l:exec_args   . (!empty(l:options) ? ' ' . l:options : '')   . ' --format=default'   . l:display_name_args . ' -'

FUNCTION  ale_linters#python#flake8#RunWithVersionCheck()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:27
Called 2 times
Total time:   0.013815
 Self time:   0.000085

count  total (s)   self (s)
    2   0.006728   0.000019     let l:executable = ale_linters#python#flake8#GetExecutable(a:buffer)
                            
    2   0.000053   0.000014     let l:module_string = s:UsingModule(a:buffer) ? ' -m flake8' : ''
    2   0.000062   0.000026     let l:command = ale#Escape(l:executable) . l:module_string . ' --version'
                            
    2   0.006968   0.000022     return ale#semver#RunWithVersionCheck(   a:buffer,   l:executable,   l:command,   function('ale_linters#python#flake8#GetCommand'),)

FUNCTION  ale#python#FindProjectRoot()
    Defined: ~/.vim/bundle/ale/autoload/ale/python.vim:52
Called 2 times
Total time:   0.002008
 Self time:   0.000114

count  total (s)   self (s)
    2   0.001696   0.000018     let l:ini_root = ale#python#FindProjectRootIni(a:buffer)
                            
    2              0.000004     if !empty(l:ini_root)
                                    return l:ini_root
    2              0.000002     endif
                            
    2   0.000277   0.000061     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
    2              0.000019         if !filereadable(l:path . '/__init__.py')
    2              0.000003             return l:path
                                    endif
                                endfor
                            
                                return ''

FUNCTION  <SNR>117_DisableOnLargeFile()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:456
Called 12 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   12              0.000061   if exists( 'b:ycm_largefile' )
   12              0.000027     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                py3 vimsupport.PostVimMessage( 'YouCompleteMe is disabled in this buffer;' + ' the file exceeded the max size (see YCM options).' )
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>114_VimCloseCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:88
Called 4 times
Total time:   0.052501
 Self time:   0.000213

count  total (s)   self (s)
    4              0.000024     let l:job = ch_getjob(a:channel)
    4   0.000079   0.000035     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
    4              0.000017     let l:info = get(s:job_map, l:job_id, {})
                            
    4              0.000008     if empty(l:info)
                                    return
    4              0.000003     endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
    4   0.052298   0.000054     if job_status(l:job) is# 'dead'
    4              0.000005         try
    4              0.000011             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
    4              0.000000             endif
    4              0.000004         finally
                                        " Automatically forget about the job after it's done.
    4              0.000007             if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
    4              0.000003             endif
    4              0.000003         endtry
    4              0.000000     endif

FUNCTION  <SNR>117_AllowedToCompleteInBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:480
Called 12 times
Total time:   0.001955
 Self time:   0.001517

count  total (s)   self (s)
   12              0.000111   let buftype = getbufvar( a:buffer, '&buftype' )
                            
   12              0.000102   if has_key( s:buftype_blacklist, buftype )
                                return 0
   12              0.000011   endif
                            
   12              0.000067   let filetype = getbufvar( a:buffer, '&filetype' )
   12              0.000038   if empty( filetype )
                                let filetype = 'ycm_nofiletype'
   12              0.000011   endif
                            
   12              0.000280   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( filetype, '\.' ) )
   12   0.000738   0.000409   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( filetype, '\.' ) )
                            
   12              0.000042   let allowed = whitelist_allows && blacklist_allows
                            
   12   0.000262   0.000153   if !allowed || s:DisableOnLargeFile( a:buffer )
                                return 0
   12              0.000013   endif
                            
   12              0.000017   if allowed
   12              0.000074     let s:previous_allowed_buffer_number = bufnr( a:buffer )
   12              0.000013   endif
   12              0.000018   return allowed

FUNCTION  <SNR>117_ShowHoverResult()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1402
Called 6 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    6              0.000050     call popup_hide( s:cursorhold_popup )
                            
    6              0.000033     if empty( a:response )
    6              0.000013       return
                                endif
                            
                                " Try to position the popup at the cursor, but avoid wrapping. If the
                                " longest line is > screen width (&columns), then we just have to wrap, and
                                " place the popup at the leftmost column.
                                "
                                " Find the longest line (FIXME: probably doesn't work well for multi-byte)
                                let lines = split( a:response, "\n" )
                                let len = max( map( copy( lines ), "len( v:val )" ) )
                            
                                let wrap = 0
                                let col = 'cursor'
                            
                                " max width is screen columns minus x padding (2)
                                if len >= (&columns - 2)
                                  " There's at least one line > our max - enable word wrap and draw the
                                  " popup at the leftmost column
                                  let col = 1
                                  let wrap = 1
                                endif
                            
                                let s:cursorhold_popup = popup_atcursor(   lines,   {     'col': col,     'wrap': wrap,     'padding': [ 0, 1, 0, 1 ],     'moved': 'word',     'maxwidth': &columns,     'close': 'click',     'fixed': 0,   } )
                                call setbufvar( winbufnr( s:cursorhold_popup ), '&syntax', b:ycm_hover.syntax )

FUNCTION  xolox#notes#refresh_syntax()
    Defined: ~/.vim/bundle/vim-notes/autoload/xolox/notes.vim:1122
Called 9 times
Total time:   0.001257
 Self time:   0.000835

count  total (s)   self (s)
                              " Update syntax highlighting of note names and code blocks.
    9   0.000909   0.000487   if xolox#notes#filetype_is_note(&ft) && line('$') > 1
                                let starttime = xolox#misc#timer#start()
                                call xolox#notes#highlight_names(0)
                                call xolox#notes#highlight_sources(0)
                                call xolox#misc#timer#stop("notes.vim %s: Refreshed highlighting in %s.", g:xolox#notes#version, starttime)
    9              0.000043   endif

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 7 times
Total time:   0.000571
 Self time:   0.000184

count  total (s)   self (s)
    7   0.000564   0.000177   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>119_Init()
    Defined: ~/.vim/bundle/tagbar/autoload/tagbar.vim:209
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000014     if s:checked_ctags == 2 && a:silent
    4              0.000009         return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                let s:init_done = 1
                                return 1

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:58
Called 4 times
Total time:   0.000114
 Self time:   0.000033

count  total (s)   self (s)
    4   0.000106   0.000025     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    4              0.000006     let l:obj.output = a:output

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:32
Called 10 times
Total time:   0.001510
 Self time:   0.001018

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   10              0.000063     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   10              0.000006     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   10              0.000039     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   10              0.000007     endif
                            
   10              0.000039     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   10              0.000016     if l:filetype is# ''
                                    return 1
   10              0.000006     endif
                            
                                " Do nothing for diff buffers.
   10              0.000027     if getbufvar(a:buffer, '&diff')
                                    return 1
   10              0.000008     endif
                            
                                " Do nothing for blacklisted files.
   10              0.000101     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
   10              0.000004     endif
                            
                                " Do nothing if running from command mode.
   10              0.000041     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
   10              0.000003     endif
                            
   10              0.000053     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   10              0.000016     if l:filename is# '.'
                                    return 1
   10              0.000007     endif
                            
                                " Don't start linting and so on when an operator is pending.
   10   0.000162   0.000100     if ale#util#Mode(1) is# 'no'
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing if running in the sandbox.
   10   0.000295   0.000060     if ale#util#InSandbox()
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing if the file is too large.
   10   0.000250   0.000055     if ale#FileTooLarge(a:buffer)
                                    return 1
   10              0.000006     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   10              0.000087     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
   10              0.000008     endif
                            
   10              0.000007     return 0

FUNCTION  SimpylFold#Recache()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:363
Called 2 times
Total time:   0.000395
 Self time:   0.000395

count  total (s)   self (s)
    2              0.000015     if exists('b:SimpylFold_cache')
    2              0.000377         unlet b:SimpylFold_cache
    2              0.000002     endif

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:144
Called 4 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    4              0.000012     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    4              0.000004     endif

FUNCTION  <SNR>95_ApplyPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:446
Called 2 times
Total time:   0.000452
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000006     if has_key(s:partial_timers, a:timer_id)
    2              0.000008         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    2   0.000433   0.000012         call call(l:Callback, [a:timer_id] + l:args)
    2              0.000002     endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:28
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000004     let l:found = 0
                            
    2              0.000017     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    2              0.000004     endfor
                            
    2              0.000002     if !l:found
    2              0.000006         call add(a:info.active_linter_list, a:linter)
    2              0.000002     endif

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:5
Called 10 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   10              0.000051     return call('mode', a:000)

FUNCTION  <SNR>114_VimExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:114
Called 4 times
Total time:   0.052244
 Self time:   0.000304

count  total (s)   self (s)
    4   0.000061   0.000039     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
    4              0.000012     let l:info = get(s:job_map, l:job_id, {})
                            
    4              0.000006     if empty(l:info)
                                    return
    4              0.000003     endif
                            
    4              0.000008     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
    4              0.000015     if ch_status(job_getchannel(a:job)) is# 'closed'
    4              0.000005         try
    4              0.000013             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
    4   0.052056   0.000138                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
    4              0.000006             endif
    4              0.000002         finally
                                        " Automatically forget about the job after it's done.
    4              0.000010             if has_key(s:job_map, l:job_id)
    4              0.000011                 call remove(s:job_map, l:job_id)
    4              0.000003             endif
    4              0.000002         endtry
    4              0.000002     endif

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:431
Called 2 times
Total time:   0.000928
 Self time:   0.000928

count  total (s)   self (s)
    2              0.000018     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    2              0.000016     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    2              0.000892     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  <SNR>68_exists_file()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 7 times
Total time:   0.004513
 Self time:   0.000819

count  total (s)   self (s)
    7   0.004505   0.000811   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:83
Called 2 times
Total time:   0.000399
 Self time:   0.000389

count  total (s)   self (s)
    2              0.000004     let l:info = get(s:buffer_data, a:buffer, {})
                            
    2              0.000003     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    2   0.000014   0.000004         if ale#util#InSandbox()
                                        return
    2              0.000000         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    2              0.000004         for l:filename in l:info.file_list
                                        call delete(l:filename)
    2              0.000000         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    4              0.000003         for l:directory in l:info.directory_list
    2              0.000351             call delete(l:directory, 'rf')
    4              0.000002         endfor
                            
    2              0.000005         call remove(s:buffer_data, a:buffer)
    2              0.000000     endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:353
Called 2 times
Total time:   0.000148
 Self time:   0.000130

count  total (s)   self (s)
    2              0.000002     let l:command_list = []
    2              0.000002     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    2              0.000004     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    2   0.000024   0.000015         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    2              0.000002         let l:is_dummy_sign_set = 1
    2              0.000002     endif
                            
                                " Place new items first.
    4              0.000006     for [l:line_str, l:info] in items(a:sign_map)
    2              0.000001         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
    2              0.000002             for l:item in l:info.items
    1              0.000001                 let l:item.sign_id = l:info.new_id
    2              0.000000             endfor
                            
    1              0.000002             if index(l:info.current_id_list, l:info.new_id) < 0
    1   0.000012   0.000008                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    1              0.000001             endif
    2              0.000001         endif
    4              0.000003     endfor
                            
                                " Remove signs without new IDs.
    4              0.000004     for l:info in values(a:sign_map)
    3              0.000003         for l:current_id in l:info.current_id_list
    1              0.000001             if l:current_id isnot l:info.new_id
    1   0.000007   0.000005                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000000             endif
    3              0.000001         endfor
    4              0.000003     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    2              0.000004     if l:is_dummy_sign_set && !g:ale_sign_column_always
    2   0.000012   0.000009         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    2              0.000001     endif
                            
    2              0.000002     return l:command_list

FUNCTION  <SNR>88_indent_spaces()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:39
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000020     if &softtabstop > 0
    2              0.000012         return &softtabstop
                                elseif &softtabstop < 0 && &shiftwidth > 0
                                    return &shiftwidth
                                endif
                                return &tabstop

FUNCTION  <SNR>127_build_command()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 7 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    7              0.000035   if has('unix')
    7              0.000030     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>90_is_dedented_already()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:358
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     let dedent_size = a:current - a:base
    1              0.000003     return (dedent_size < 0 && a:current % s:sw() == 0) ? 1 : 0

FUNCTION  <SNR>68_is_file_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 7 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    7              0.000116   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>117_ClearSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1152
Called 3 times
Total time:   0.000451
 Self time:   0.000314

count  total (s)   self (s)
    3   0.000142   0.000023   if !s:ShouldUseSignatureHelp()
                                return
    3              0.000002   endif
                            
    3   0.000043   0.000025   call s:StopPoller( s:pollers.signature_help )
    3              0.000010   let s:signature_help = s:default_signature_help
    3              0.000245   call py3eval( 'ycm_state.ClearSignatureHelp()' )

FUNCTION  <SNR>117_ShouldUseSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1070
Called 8 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
    8              0.000285   return py3eval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  <SNR>90_indent_like_opening_paren()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:210
Called 1 time
Total time:   0.000179
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000176   0.000014     let [paren_lnum, paren_col] = s:find_opening_paren(a:lnum, 1)
    1              0.000002     if paren_lnum <= 0
    1              0.000001         return -2
                                endif
                                let text = getline(paren_lnum)
                                let base = indent(paren_lnum)
                            
                                let nothing_after_opening_paren = s:match_expr_on_line( s:skip_after_opening_paren, paren_lnum, paren_col+1)
                                let starts_with_closing_paren = getline(a:lnum) =~# '^\s*[])}]'
                            
                                let hang_closing = get(b:, 'python_pep8_indent_hang_closing', get(g:, 'python_pep8_indent_hang_closing', 0))
                            
                                if nothing_after_opening_paren
                                    if starts_with_closing_paren && !hang_closing
                                        let res = base
                                    else
                                        let res = base + s:sw()
                            
                                        " Special case for parenthesis.
                                        if text[paren_col-1] ==# '(' && getline(a:lnum) !~# '\v\)\s*:?\s*$'
                                            return res
                                        endif
                                    endif
                                else
                                    " Indent to match position of opening paren.
                                    let res = paren_col
                                endif
                            
                                " If this line is the continuation of a control statement
                                " indent further to distinguish the continuation line
                                " from the next logical line.
                                if text =~# b:control_statement && res == base + s:sw()
                                    " But only if not inside parens itself (Flake's E127).
                                    let [paren_lnum, _] = s:find_opening_paren(paren_lnum, 1)
                                    if paren_lnum <= 0
                                        return res + s:sw()
                                    endif
                                endif
                                return res

FUNCTION  <SNR>90_indent_like_previous_line()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:288
Called 1 time
Total time:   0.000527
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000006     let lnum = prevnonblank(a:lnum - 1)
                            
                                " No previous line, keep current indent.
    1              0.000001     if lnum < 1
                                  return -1
    1              0.000001     endif
                            
    1              0.000003     let text = getline(lnum)
    1   0.000395   0.000011     let start = s:find_start_of_multiline_statement(lnum)
    1              0.000003     let base = indent(start)
    1              0.000002     let current = indent(a:lnum)
                            
                                " Ignore last character in previous line?
    1              0.000003     let lastcol = len(text)
    1              0.000001     let col = lastcol
                            
                                " Search for final colon that is not inside something to be ignored.
    1              0.000001     while 1
    1              0.000003         if col == 1 | break | endif
    1   0.000030   0.000012         if text[col-1] =~# '\s' || s:_skip_special_chars(lnum, col)
                                        let col = col - 1
                                        continue
    1              0.000002         elseif text[col-1] ==# ':'
                                        return base + s:sw()
    1              0.000001         endif
    1              0.000001         break
    1              0.000002     endwhile
                            
    1              0.000004     if text =~# '\\$' && !s:_skip_special_chars(lnum, lastcol)
                                    " If this line is the continuation of a control statement
                                    " indent further to distinguish the continuation line
                                    " from the next logical line.
                                    if getline(start) =~# b:control_statement
                                        return base + s:sw() * 2
                                    endif
                            
                                    " Nest (other) explicit continuations only one level deeper.
                                    return base + s:sw()
    1              0.000001     endif
                            
    1              0.000005     let empty = getline(a:lnum) =~# '^\s*$'
                            
                                " Current and prev line are empty, next is not -> indent like next.
    1              0.000004     if empty && a:lnum > 1 && (getline(a:lnum - 1) =~# '^\s*$') && !(getline(a:lnum + 1) =~# '^\s*$')
                                  return indent(a:lnum + 1)
    1              0.000000     endif
                            
                                " If the previous statement was a stop-execution statement or a pass
    1              0.000007     if getline(start) =~# s:stop_statement
                                    " Remove one level of indentation if the user hasn't already dedented
                                    if empty || current > base - s:sw()
                                        return base - s:sw()
                                    endif
                                    " Otherwise, trust the user
                                    return -1
    1              0.000000     endif
                            
    1   0.000017   0.000011     if (current || !empty) && s:is_dedented_already(current, base)
                                    return -1
    1              0.000001     endif
                            
                                " In all other cases, line up with the start of the previous statement.
    1              0.000001     return base

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:239
Called 3 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    3              0.000004     let l:msg = a:format_string
    3              0.000005     let l:severity = g:ale_echo_msg_warning_str
    3              0.000007     let l:code = get(a:item, 'code', '')
    3              0.000007     let l:type = get(a:item, 'type', 'E')
    3              0.000008     let l:linter_name = get(a:item, 'linter_name', '')
    3              0.000010     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    3              0.000003     if l:type is# 'E'
    3              0.000006         let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    3              0.000001     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    3              0.000070     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
    3              0.000017     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    3              0.000014     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
    3              0.000018     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
    3              0.000011     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
    3              0.000003     return l:msg

FUNCTION  <SNR>117_PollFileParseResponse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:753
Called 2 times
Total time:   0.001114
 Self time:   0.001114

count  total (s)   self (s)
    2              0.000398   if !py3eval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
    2              0.000001   endif
                            
    2              0.000660   py3 ycm_state.HandleFileParseRequest()
    2              0.000030   if py3eval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
    2              0.000001   endif

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:82
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000009     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    2              0.000002     endif
                            
    2              0.000002     return 0

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:24
Called 10 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
   10              0.000141     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   10              0.000041     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:43
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000008     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>88_multi_string()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:121
Called 204 times
Total time:   0.014212
 Self time:   0.011327

count  total (s)   self (s)
                                " 2x performance for general case
  204              0.001333     if a:line !~# '[''"]'
  142              0.000478         return [a:in_string, 0, 0, '', '']
   62              0.000058     endif
                            
   62   0.002237   0.000612     let string_match = s:matchstrpos(a:line, a:first_re)
   62              0.000160     if string_match[1] == -1
                                    return [a:in_string, 0, 0, '', '']
   62              0.000060     endif
                            
                                " Anything before first match?
   62              0.000127     if string_match[1] >= 1
   62              0.000247         let before_first = a:line[:(string_match[1] - 1)]
                                else
                                    let before_first = ''
   62              0.000055     endif
                            
   62              0.000134     let in_string = a:in_string
   62              0.000106     let next_re = ''
   62              0.000124     let line_slice = a:line
   62              0.000106     let found_ends = 0
  156              0.000330     while string_match[1] != -1
  112              0.000126         if in_string
   56              0.000087             let in_string = 0
   56              0.000089             let found_ends += 1
   56              0.000118             let next_re = s:string_start_re
   56              0.000051         else
   56              0.000087             let in_string = 1
   56              0.000564             let quotes = string_match[0][matchend(string_match[0], s:string_prefix_re):]
   56              0.000149             let next_re = '\\\@<!' . quotes
  112              0.000100         endif
                            
  112              0.000382         let line_slice = line_slice[(string_match[2]):]
  112              0.000289         if empty(line_slice)
   18              0.000020             break
   94              0.000083         endif
   94   0.002081   0.000821         let string_match = s:matchstrpos(line_slice, next_re)
  156              0.000304     endwhile
                            
   62              0.000088     if in_string
                                    " Check if in single quoted string and line continues
   20              0.000118         let single_quoted = quotes =~# '^[''"]$'
   20              0.000049         if single_quoted && line_slice !~# s:line_cont_re
                                        return [0, single_quoted, (found_ends >= 1), '', before_first]
   20              0.000021         else
   20              0.000089             return [1, single_quoted, (found_ends >= 1), next_re, before_first]
                                    endif
   42              0.000036     else
   42              0.000153         return [0, 0, (found_ends >= 2), '', before_first]
                                endif

FUNCTION  <SNR>117_PollCompletion()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1025
Called 2 times
Total time:   0.000246
 Self time:   0.000213

count  total (s)   self (s)
    2              0.000105   if !py3eval( 'ycm_state.CompletionRequestReady()' )
    1              0.000011     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
    1              0.000001     return
    1              0.000001   endif
                            
    1              0.000085   let s:completion = py3eval( 'ycm_state.GetCompletionResponse()' )
    1   0.000039   0.000006   call s:Complete()

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:101
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000018     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    6              0.000032     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:39
Called 6 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    6              0.000017     if has_key(s:buffer_data, a:buffer)
    6              0.000019         let s:buffer_data[a:buffer].cwd = v:null
    6              0.000004     endif

FUNCTION  ale#Var()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:180
Called 159 times
Total time:   0.002008
 Self time:   0.002008

count  total (s)   self (s)
  159              0.000437     let l:full_name = 'ale_' . a:variable_name
  159              0.000781     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  159              0.000640     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  ale#python#FindVirtualenv()
    Defined: ~/.vim/bundle/ale/autoload/ale/python.vim:69
Called 10 times
Total time:   0.031914
 Self time:   0.017502

count  total (s)   self (s)
   80   0.002026   0.000574     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " Skip empty path components returned in MSYS.
   70              0.000138         if empty(l:path)
                                        continue
   70              0.000048         endif
                            
  560   0.001723   0.000928         for l:dirname in ale#Var(a:buffer, 'virtualenv_dir_names')
  490   0.010426   0.004230             let l:venv_dir = ale#path#Simplify(   join([l:path, l:dirname], s:sep))
  490   0.010517   0.004548             let l:script_filename = ale#path#Simplify(   join([l:venv_dir, s:bin_dir, 'activate'], s:sep))
                            
  490              0.004403             if filereadable(l:script_filename)
                                            return l:venv_dir
  490              0.000362             endif
  560              0.000390         endfor
   80              0.000066     endfor
                            
   10              0.000031     return $VIRTUAL_ENV

FUNCTION  ale#python#FindProjectRootIni()
    Defined: ~/.vim/bundle/ale/autoload/ale/python.vim:19
Called 4 times
Total time:   0.003794
 Self time:   0.003291

count  total (s)   self (s)
   32   0.000709   0.000206     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " If you change this, update ale-python-root documentation.
   28              0.002924         if filereadable(l:path . '/MANIFEST.in')|| filereadable(l:path . '/setup.cfg')|| filereadable(l:path . '/pytest.ini')|| filereadable(l:path . '/tox.ini')|| filereadable(l:path . '/mypy.ini')|| filereadable(l:path . '/pycodestyle.cfg')|| filereadable(l:path . '/.flake8')|| filereadable(l:path . '/.flake8rc')|| filereadable(l:path . '/pylama.ini')|| filereadable(l:path . '/pylintrc')|| filereadable(l:path . '/.pylintrc')|| filereadable(l:path . '/Pipfile')|| filereadable(l:path . '/Pipfile.lock')|| filereadable(l:path . '/poetry.lock')|| filereadable(l:path . '/pyproject.toml')
                                        return l:path
   28              0.000021         endif
   32              0.000024     endfor
                            
    4              0.000004     return ''

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 7 times
Total time:   0.000610
 Self time:   0.000610

count  total (s)   self (s)
    7              0.000023   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    7              0.000013   endif

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:192
Called 4 times
Total time:   0.002535
 Self time:   0.000709

count  total (s)   self (s)
    4              0.000008     let l:temporary_file = ''
    4              0.000008     let l:command = a:command
                            
    4              0.000025     if !empty(a:cwd)
    2   0.000077   0.000017         let l:command = ale#command#CdString(a:cwd) . l:command
    4              0.000004     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    4              0.000033     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    4              0.000024     if !empty(a:executable) && l:command =~# '%e'
    2   0.000084   0.000035         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    4              0.000004     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    4              0.000013     if l:command =~# '%s'
    2              0.000108         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    2   0.000219   0.000077         let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    4              0.000004     endif
                            
    4              0.000022     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    4              0.000003     endif
                            
                                " Finish formatting so %% becomes %.
    4              0.000033     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    4              0.000014     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    2   0.000127   0.000024         let l:temporary_file = s:TemporaryFilename(a:buffer)
    2   0.000043   0.000014         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    4              0.000003     endif
                            
    4   0.001531   0.000088     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    4              0.000014     return [l:temporary_file, l:command, l:file_created]

FUNCTION  ale#job#ParseVim8ProcessID()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:140
Called 15 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
   15              0.000190     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  ale#command#Run()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:333
Called 4 times
Total time:   0.010338
 Self time:   0.001185

count  total (s)   self (s)
    4              0.000017     let l:options = get(a:000, 0, {})
                            
    4              0.000013     if len(a:000) > 1
                                    throw 'Too many arguments!'
    4              0.000004     endif
                            
    4              0.000019     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    4              0.000006     let l:line_list = []
    4              0.000017     let l:cwd = get(l:options, 'cwd', v:null)
                            
    4              0.000009     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
    2              0.000017         let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
    4              0.000003     endif
                            
    4   0.002644   0.000109     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
    4   0.000389   0.000046     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    4              0.000078     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    4              0.000011     if l:output_stream is# 'stdout'
    2              0.000015         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    2              0.000005     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    2              0.000004     elseif l:output_stream is# 'both'
    2              0.000021         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    2              0.000013         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    4              0.000004     endif
                            
    4              0.000008     let l:status = 'failed'
                            
    4              0.000014     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    4              0.000011     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    4              0.000005     else
    4   0.005847   0.000101         let l:job_id = ale#job#Start(l:command, l:job_options)
    4              0.000004     endif
                            
    4              0.000006     if l:job_id
    4              0.000009         let l:status = 'started'
    4              0.000022         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    4   0.000135   0.000063         call ale#command#InitData(a:buffer)
    4              0.000032         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    4              0.000004     endif
                            
    4              0.000007     if g:ale_history_enabled
    4   0.000511   0.000054         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    4              0.000005     endif
                            
    4              0.000005     if !l:job_id
                                    return 0
    4              0.000003     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
    4              0.000037     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
    4              0.000015     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    4              0.000003     endif
                            
    4              0.000015     return l:result

FUNCTION  ale_linters#python#flake8#GetExecutable()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:14
Called 6 times
Total time:   0.021696
 Self time:   0.000187

count  total (s)   self (s)
    6   0.000234   0.000070     if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_flake8_auto_pipenv')) && ale#python#PipenvPresent(a:buffer)
                                    return 'pipenv'
    6              0.000004     endif
                            
    6   0.000183   0.000036     if !s:UsingModule(a:buffer)
    6   0.021257   0.000059         return ale#python#FindExecutable(a:buffer, 'python_flake8', ['flake8'])
                                endif
                            
                                return ale#Var(a:buffer, 'python_flake8_executable')

FUNCTION  <SNR>125_CloseWindowIfNeeded()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:207
Called 2 times
Total time:   0.000051
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000050   0.000015     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    2              0.000000         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:471
Called 44 times
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
   44              0.000209     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.vim/bundle/vim-misc/autoload/xolox/misc/cursorhold.vim:48
Called 7 times
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    7              0.000091   for handler in g:xolox#misc#cursorhold#handlers
                                let function = handler['function']
                                let last_run = get(handler, 'last_run', 0)
                                let interval = get(handler, 'interval', 4)
                                call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
                                let time_until_next_run = (last_run + interval) - localtime()
                                if time_until_next_run > 0
                                  call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
                                else
                                  call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
                                  call call(function, get(handler, 'arguments', []))
                                  let handler['last_run'] = localtime()
                                endif
    7              0.000057   endfor

FUNCTION  <SNR>90__skip_special_chars()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:82
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000018         return synIDattr(synID(a:line, a:col, 0), 'name') =~? s:special_chars_syn_pattern

FUNCTION  <SNR>117_PollCommand()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1288
Called 6 times
Total time:   0.008406
 Self time:   0.008210

count  total (s)   self (s)
    6              0.000735   if py3eval( 'ycm_state.GetCommandRequest() is None' )
                                " Possible in case of race conditions and things like RestartServer
                                " But particualrly in the tests
                                return
    6              0.000013   endif
                            
    6              0.000268   if !py3eval( 'ycm_state.GetCommandRequest().Done()' )
                                let s:pollers.command.id = timer_start( s:pollers.command.wait_milliseconds, function( 's:PollCommand', [ a:response_func, a:callback ] ) )
                                return
    6              0.000006   endif
                            
    6   0.000304   0.000220   call s:StopPoller( s:pollers.command )
                            
    6              0.006685   let result = py3eval( 'ycm_state.GetCommandRequest().' .a:response_func . '()' )
                            
    6   0.000244   0.000132   eval a:callback( result )

FUNCTION  <SNR>113_TemporaryFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:132
Called 2 times
Total time:   0.000103
 Self time:   0.000053

count  total (s)   self (s)
    2              0.000008     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    2              0.000004     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    2              0.000000     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    2   0.000072   0.000022     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  ale_linters#python#pylint#GetExecutable()
    Defined: ~/.vim/bundle/ale/ale_linters/python/pylint.vim:11
Called 2 times
Total time:   0.005765
 Self time:   0.000040

count  total (s)   self (s)
    2   0.000062   0.000021     if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_pylint_auto_pipenv')) && ale#python#PipenvPresent(a:buffer)
                                    return 'pipenv'
    2              0.000000     endif
                            
    2   0.005699   0.000015     return ale#python#FindExecutable(a:buffer, 'python_pylint', ['pylint'])

FUNCTION  ale_linters#python#flake8#GetCwd()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:41
Called 2 times
Total time:   0.002214
 Self time:   0.000074

count  total (s)   self (s)
    2   0.000038   0.000014     let l:change_directory = ale#Var(a:buffer, 'python_flake8_change_directory')
    2              0.000002     let l:cwd = ''
                            
    2              0.000004     if l:change_directory is# 'project'
    2   0.002134   0.000018         let l:project_root = ale#python#FindProjectRootIni(a:buffer)
                            
    2              0.000005         if !empty(l:project_root)
                                        let l:cwd = l:project_root
    2              0.000002         endif
    2              0.000002     endif
                            
    2              0.000011     if (l:change_directory is# 'project' && empty(l:cwd))|| l:change_directory is# 1|| l:change_directory is# 'file'
    2              0.000002         let l:cwd = '%s:h'
    2              0.000001     endif
                            
    2              0.000003     return l:cwd

FUNCTION  <SNR>90_indent_like_block()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:255
Called 1 time
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000003     let text = getline(a:lnum)
    3              0.000009     for [multiple, block_rules] in [ [0, s:block_rules], [1, s:block_rules_multiple], ]
    6              0.000018         for [line_re, blocks_ignore] in items(block_rules)
    4              0.000015             if text !~# line_re
    4              0.000004                 continue
                                        endif
                            
                                        let [blocks, skip] = blocks_ignore
                                        let indents = s:find_start_of_block(a:lnum, blocks, skip, multiple)
                                        if empty(indents)
                                            return -1
                                        endif
                                        if len(indents) == 1
                                            return indents[0]
                                        endif
                            
                                        " Multiple valid indents, e.g. for 'else' with both try and if.
                                        let indent = indent(a:lnum)
                                        if index(indents, indent) != -1
                                            " The indent is valid, keep it.
                                            return indent
                                        endif
                                        " Fallback to the first/nearest one.
                                        return indents[0]
    2              0.000002         endfor
    3              0.000005     endfor
    1              0.000001     return -2

FUNCTION  <SNR>111_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:477
Called 2 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    2              0.000005     let l:name_map = {}
                            
   10              0.000016     for l:linter in a:linters
    8              0.000023         let l:name_map[l:linter.name] = 1
   10              0.000012     endfor
                            
    2              0.000032     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>125_FixList()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:60
Called 2 times
Total time:   0.000104
 Self time:   0.000046

count  total (s)   self (s)
    2   0.000024   0.000007     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    2              0.000002     let l:new_list = []
                            
    3              0.000003     for l:item in a:list
    1              0.000003         let l:fixed_item = copy(l:item)
                            
    1   0.000046   0.000005         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    1              0.000001         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
    1              0.000001         endif
                            
    1              0.000002         call add(l:new_list, l:fixed_item)
    3              0.000003     endfor
                            
    2              0.000002     return l:new_list

FUNCTION  <SNR>124_GroupCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:164
Called 8 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    8              0.000006     if s:supports_sign_groups
    8              0.000006         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>125_SetListsImpl()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:84
Called 2 times
Total time:   0.000421
 Self time:   0.000217

count  total (s)   self (s)
    2              0.000046     let l:title = expand('#' . a:buffer . ':p')
                            
    2              0.000001     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    2              0.000002     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    2   0.000019   0.000010         let l:ids = s:WinFindBuf(a:buffer)
                            
    4              0.000004         for l:id in l:ids
    2              0.000005             if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
    2              0.000002             else
    2   0.000119   0.000015                 call setloclist(l:id, s:FixList(a:buffer, a:loclist))
    2              0.000007                 call setloclist(l:id, [], 'r', {'title': l:title})
    2              0.000001             endif
    4              0.000003         endfor
    2              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    2              0.000008     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    2   0.000035   0.000009     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    2              0.000000     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    2   0.000019   0.000005     if !ale#engine#IsCheckingBuffer(a:buffer)
    2   0.000061   0.000010         call s:CloseWindowIfNeeded(a:buffer)
    2              0.000000     endif

FUNCTION  ale#semver#ParseVersion()
    Defined: ~/.vim/bundle/ale/autoload/ale/semver.vim:8
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    4              0.000009     for l:line in a:version_lines
    2              0.000037         let l:match = matchlist(l:line, '\v(\d+)\.(\d+)(\.(\d+))?')
                            
    2              0.000006         if !empty(l:match)
                                        return [l:match[1] + 0, l:match[2] + 0, l:match[4] + 0]
    2              0.000001         endif
    4              0.000006     endfor
                            
    2              0.000002     return []

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:53
Called 8 times
Total time:   0.000819
 Self time:   0.000421

count  total (s)   self (s)
    8              0.000015     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    8              0.000006     endif
                            
                                " Check for a cached executable() check.
    8              0.000036     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    8              0.000017     if l:result isnot v:null
    2              0.000002         return l:result
    6              0.000001     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    6              0.000194     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    6              0.000020     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
    6              0.000004     endif
                            
    6              0.000007     if g:ale_history_enabled
    6   0.000447   0.000049         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    6              0.000003     endif
                            
    6              0.000009     return l:result

FUNCTION  ale#Escape()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:219
Called 12 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
   12              0.000056     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
   12              0.000008     endif
                            
   12              0.000046     return shellescape (a:str)

FUNCTION  GetPythonPEPIndent()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:380
Called 1 time
Total time:   0.001141
 Self time:   0.000163

count  total (s)   self (s)
                                " First line has indent 0
    1              0.000001     if a:lnum == 1
                                    return 0
    1              0.000001     endif
                            
    1              0.000007     let line = getline(a:lnum)
    1              0.000003     let prevline = getline(a:lnum-1)
                            
                                " Multilinestrings: continous, docstring or starting.
    1   0.000165   0.000019     if s:is_python_string(a:lnum-1, max([1, len(prevline)])) && (s:is_python_string(a:lnum, 1)     || match(line, '^\%("""\|''''''\)') != -1)
                            
                                    " Indent closing quotes as the line with the opening ones.
                                    let match_quotes = match(line, '^\s*\zs\%("""\|''''''\)')
                                    if match_quotes != -1
                                        " closing multiline string
                                        let quotes = line[match_quotes:(match_quotes+2)]
                                        call cursor(a:lnum, 1)
                                        let pairpos = searchpairpos(quotes, '', quotes, 'bW', '', 0, g:python_pep8_indent_searchpair_timeout)
                                        if pairpos[0] != 0
                                            return indent(pairpos[0])
                                        else
                                            return -1
                                        endif
                                    endif
                            
                                    if s:is_python_string(a:lnum-1)
                                        " Previous line is (completely) a string: keep current indent.
                                        return -1
                                    endif
                            
                                    if match(prevline, '^\s*\%("""\|''''''\)') != -1
                                        " docstring.
                                        return indent(a:lnum-1)
                                    endif
                            
                                    let indent_multi = get(b:, 'python_pep8_indent_multiline_string', get(g:, 'python_pep8_indent_multiline_string', 0))
                                    if match(prevline, '\v%("""|'''''')$') != -1
                                        " Opening multiline string, started in previous line.
                                        if (&autoindent && indent(a:lnum) == indent(a:lnum-1)) || match(line, '\v^\s+$') != -1
                                            " <CR> with empty line or to split up 'foo("""bar' into
                                            " 'foo("""' and 'bar'.
                                            if indent_multi == -2
                                                return indent(a:lnum-1) + s:sw()
                                            endif
                                            return indent_multi
                                        endif
                                    endif
                            
                                    " Keep existing indent.
                                    if match(line, '\v^\s*\S') != -1
                                        return -1
                                    endif
                            
                                    if indent_multi != -2
                                        return indent_multi
                                    endif
                            
                                    return s:indent_like_opening_paren(a:lnum)
    1              0.000001     endif
                            
                                " Parens: If we can find an open parenthesis/bracket/brace, line up with it.
    1   0.000199   0.000020     let indent = s:indent_like_opening_paren(a:lnum)
    1              0.000001     if indent >= -1
                                    return indent
    1              0.000000     endif
                            
                                " Blocks: Match indent of first block of this type.
    1   0.000135   0.000009     let indent = s:indent_like_block(a:lnum)
    1              0.000002     if indent >= -1
                                    return indent
    1              0.000000     endif
                            
    1   0.000548   0.000021     return s:indent_like_previous_line(a:lnum)

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 7 times
Total time:   0.004094
 Self time:   0.000410

count  total (s)   self (s)
    7   0.001956   0.000293   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    7   0.002128   0.000107   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>126_matchaddpos()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:89
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000000     if s:has_nvim_highlight
                                    for l:pos in a:pos_list
                                        let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
                                        if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
                                            let l:col_start = l:pos[1] - 1
                                            let l:col_end = l:col_start + get(l:pos, 2, 1)
                                        endif
                            
                                        call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
                                    endfor
    1              0.000001     else
    1              0.000003         call matchaddpos(a:group, a:pos_list)
    1              0.000001     endif

FUNCTION  <SNR>117_ClosePreviewWindowIfNeeded()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:905
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000010   let current_buffer_name = bufname('')
                            
                              " We don't want to try to close the preview window in special buffers like
                              " "[Command Line]"; if we do, Vim goes bonkers. Special buffers always start
                              " with '['.
    2              0.000008   if current_buffer_name[ 0 ] == '['
                                return
    2              0.000001   endif
                            
                              " This command does the actual closing of the preview window. If no preview
                              " window is shown, nothing happens.
    2              0.000002   pclose

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:300
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000005     let l:clear_tempdir = 0
                            
    2              0.000012     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    2              0.000001     endif
                            
    2              0.000002     try
    2              0.000007         let l:name = tempname() " no-custom-checks
    2              0.000004     finally
    2              0.000004         if l:clear_tempdir
                                        let $TMPDIR = ''
    2              0.000001         endif
    2              0.000002     endtry
                            
    2              0.000002     return l:name

FUNCTION  <SNR>68_filename()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 7 times
Total time:   0.001357
 Self time:   0.000149

count  total (s)   self (s)
    7   0.001353   0.000145   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>79_Remove_Matches()
    Defined: /opt/homebrew/share/vim/vim82/plugin/matchparen.vim:197
Called 6 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    6              0.000029   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    6              0.000006   endif

FUNCTION  <SNR>123_StartIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:365
Called 2 times
Total time:   0.000253
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000019   0.000012     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
    2              0.000002     endif
                            
    2   0.000222   0.000018     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
    2              0.000002         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  <SNR>113_ExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:285
Called 4 times
Total time:   0.051808
 Self time:   0.000335

count  total (s)   self (s)
    4              0.000013     if !has_key(s:buffer_data, a:buffer)
                                    return
    4              0.000001     endif
                            
    4              0.000015     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    4              0.000011     if !has_key(l:jobs, a:data.job_id)
                                    return
    4              0.000002     endif
                            
    4              0.000012     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    4              0.000007     if g:ale_history_enabled
    4   0.000198   0.000035         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    4              0.000010         if g:ale_history_log_output && a:data.log_output is 1
    4   0.000143   0.000029             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    4              0.000004         endif
    4              0.000002     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    4              0.000027     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    4   0.003152   0.000043     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    4              0.000006     let l:result = a:data.result
    4              0.000007     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    4   0.000083   0.000022     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    4              0.000004     try
    4              0.000012         if get(l:result, 'result_callback', v:null) isnot v:null
    2   0.048017   0.000016             call call(l:result.result_callback, [l:value])
    4              0.000001         endif
    4              0.000004     finally
    4   0.000040   0.000015         call ale#command#ResetCwd(a:buffer)
    4              0.000003     endtry

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 21 times
Total time:   0.001077
 Self time:   0.001077

count  total (s)   self (s)
   21              0.000989   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   21              0.000058     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:439
Called 2 times
Total time:   0.013850
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000009     let l:Command = a:linter.command
                            
    2   0.013838   0.000023     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  tagbar#currenttag()
    Defined: ~/.vim/bundle/tagbar/autoload/tagbar.vim:3822
Called 4 times
Total time:   0.000297
 Self time:   0.000270

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
    4              0.000029     let s:statusline_in_use = 1
                            
    4              0.000011     if a:0 >= 1
                                    " also test for non-zero value for backwards compatibility
    4              0.000060         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
    4              0.000014         let fullpath  = a:1 =~# 'f'
    4              0.000011         let prototype = a:1 =~# 'p'
    4              0.000005         if a:0 >= 2
                                        let search_method = a:2
    4              0.000007         else
    4              0.000009             let search_method = 'nearest-stl'
    4              0.000003         endif
                                else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                    let search_method = 'nearest-stl'
    4              0.000004     endif
                            
    4   0.000080   0.000053     if !s:Init(1)
    4              0.000008         return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(search_method, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>111_RunLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:579
Called 8 times
Total time:   0.046455
 Self time:   0.000205

count  total (s)   self (s)
    8              0.000021     if !empty(a:linter.lsp)
    2   0.002581   0.000013         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    6              0.000005     else
    6   0.020380   0.000056         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    6   0.023443   0.000085         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  <SNR>111_HandleExit()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:151
Called 2 times
Total time:   0.002885
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000008     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    2              0.000002     if empty(l:buffer_info)
                                    return
    2              0.000000     endif
                            
    2              0.000002     let l:linter = a:job_info.linter
    2              0.000002     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    2   0.000020   0.000012     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    2   0.000036   0.000008     if ale#util#InSandbox()
                                    return
    2              0.000001     endif
                            
    2              0.000007     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    2              0.000000     endif
                            
    2              0.000001     try
    2   0.000267   0.000017         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    2              0.000001     endtry
                            
    2   0.002525   0.000009     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 7 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    7              0.000042   return s:available

FUNCTION  ale#python#HandleTraceback()
    Defined: ~/.vim/bundle/ale/autoload/ale/python.vim:119
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000003     let l:nlines = len(a:lines)
    2              0.000004     let l:limit = a:limit > l:nlines ? l:nlines : a:limit
    2              0.000002     let l:start = 0
                            
    3              0.000003     while l:start < l:limit
    1              0.000002         if a:lines[l:start] is# 'Traceback (most recent call last):'
                                        break
    1              0.000000         endif
                            
    1              0.000001         let l:start += 1
    3              0.000003     endwhile
                            
    2              0.000002     if l:start >= l:limit
    2              0.000002         return []
                                endif
                            
                                let l:end = l:start + 1
                            
                                " Traceback entries are always prefixed with 2 spaces.
                                " SyntaxError marker (if present) is prefixed with at least 4 spaces.
                                " Final exc line starts with exception class name (never a space).
                                while l:end < l:nlines && a:lines[l:end][0] is# ' '
                                    let l:end += 1
                                endwhile
                            
                                let l:exc_line = l:end < l:nlines   ? a:lines[l:end]   : 'An exception was thrown.'
                            
                                return [{   'lnum': 1,   'text': l:exc_line . ' (See :ALEDetail)',   'detail': join(a:lines[(l:start):(l:end)], "\n"),}]

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:385
Called 2 times
Total time:   0.002520
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000005     let l:command = ''
    2              0.000003     let l:address = ''
    2   0.002142   0.000017     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    2              0.000006     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
    2              0.000001     endif
                            
    2              0.000010     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    2              0.000002     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
    2              0.000002     endif
                            
    2   0.000063   0.000014     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    2   0.000268   0.000015     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:182
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000002     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " строка=1  id=1000001  группа=ale  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  グループ=ale  名前=ALEWarningSign
                                    " línea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
    2              0.000002         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " строка=1  id=1000001  имя=ALEErrorSign
                                    " 行=1  識別子=1000001  名前=ALEWarningSign
                                    " línea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    2              0.000000     endif
                            
    2              0.000002     return l:pattern

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:231
Called 6 times
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
    6              0.000010     let l:min = 0
    6              0.000021     let l:max = len(a:loclist) - 1
                            
    7              0.000010     while 1
    7              0.000012         if l:max < l:min
    4              0.000004             return -1
    3              0.000002         endif
                            
    3              0.000008         let l:mid = (l:min + l:max) / 2
    3              0.000017         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    3              0.000008         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
    3              0.000005         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
    3              0.000005         elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
    3              0.000005         elseif l:item.lnum > a:line
    1              0.000003             let l:max = l:mid - 1
    2              0.000002         else
                                        " This part is a small sequential search.
    2              0.000004             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    2              0.000008             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
    2              0.000003             endwhile
                            
                                        " Find the last problem on or before this column.
    2              0.000009             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
    2              0.000001             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    2              0.000006             let l:item_column = a:loclist[l:index].col
                            
    2              0.000009             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
    2              0.000003             endwhile
                            
    2              0.000003             return l:index
    1              0.000001         endif
    1              0.000001     endwhile

FUNCTION  <SNR>117_IdentifierFinishedOperations()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:921
Called 1 time
Total time:   0.000691
 Self time:   0.000691

count  total (s)   self (s)
    1              0.000039   if !py3eval( 'base.CurrentIdentifierFinished()' )
                                return
    1              0.000000   endif
    1              0.000642   py3 ycm_state.OnCurrentIdentifierFinished()
    1              0.000004   let s:force_semantic = 0
    1              0.000003   let s:completion = s:default_completion

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:207
Called 2 times
Total time:   0.000170
 Self time:   0.000156

count  total (s)   self (s)
    2   0.000024   0.000010     let l:pattern =ale#sign#ParsePattern()
    2              0.000002     let l:result = []
    2              0.000002     let l:is_dummy_sign_set = 0
                            
    6              0.000004     for l:line in a:line_list
    4              0.000088         let l:match = matchlist(l:line, l:pattern)
                            
    4              0.000005         if len(l:match) > 0
    1              0.000002             if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
    1              0.000001             else
    1              0.000004                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
    1              0.000000             endif
    4              0.000001         endif
    6              0.000005     endfor
                            
    2              0.000003     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:128
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
    1              0.000001     endif
                            
    1              0.000001     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
    1              0.000000     endif
                            
    1              0.000001     if get(a:item, 'sub_type', '') is# 'style'
    1              0.000001         return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:679
Called 2 times
Total time:   0.006106
 Self time:   0.000157

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    2   0.000069   0.000038     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    2   0.006033   0.000115     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 14 times
Total time:   0.000604
 Self time:   0.000604

count  total (s)   self (s)
   14              0.000066   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   14              0.000102   let ggvars = getbufvar(buffer, 'gitgutter')
   14              0.000081   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   14              0.000019   endif
   14              0.000109   let ggvars[a:varname] = a:val

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:13
Called 2 times
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
    2              0.000004     let l:message = a:original_message
                                " Change tabs to spaces.
    2              0.000010     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    2              0.000008     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    2              0.000008     let l:shortmess_options = &l:shortmess
                            
    2              0.000002     try
    2              0.000005         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    2              0.000025         silent! setlocal shortmess+=T
                            
    2              0.000002         try
    2              0.000190             exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
    2              0.000001         endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    2              0.000009         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
    2              0.000002         endif
    2              0.000002     finally
    2              0.000010         let &l:shortmess = l:shortmess_options
    2              0.000001     endtry

FUNCTION  <SNR>98_UsingModule()
    Defined: ~/.vim/bundle/ale/ale_linters/python/flake8.vim:10
Called 8 times
Total time:   0.000186
 Self time:   0.000080

count  total (s)   self (s)
    8   0.000182   0.000076     return ale#Var(a:buffer, 'python_flake8_options') =~# ' *-m flake8'

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:484
Called 6 times
Total time:   0.000472
 Self time:   0.000187

count  total (s)   self (s)
    6              0.000039     let l:info = get(g:ale_buffer_info, a:buffer, {})
    6              0.000021     let l:loclist = get(l:info, 'loclist', [])
    6              0.000020     let l:pos = getpos('.')
    6   0.000351   0.000066     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    6              0.000019     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    6              0.000012     return [l:info, l:loc]

FUNCTION  ale#history#Add()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:12
Called 10 times
Total time:   0.000855
 Self time:   0.000855

count  total (s)   self (s)
   10              0.000021     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   10              0.000008     endif
                            
   10              0.000054     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   10              0.000029     if len(l:history) >= g:ale_max_buffer_history_size
    7              0.000209         let l:history = l:history[1:]
   10              0.000006     endif
                            
   10              0.000059     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   10              0.000372     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>115_FindHistoryItem()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:36
Called 8 times
Total time:   0.000195
 Self time:   0.000137

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   20   0.000125   0.000067     for l:obj in reverse(ale#history#Get(a:buffer))
   20              0.000020         if l:obj.job_id == a:job_id
    8              0.000008             return l:obj
   12              0.000004         endif
   12              0.000004     endfor
                            
                                return {}

FUNCTION  ale#python#FindExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/python.vim:96
Called 10 times
Total time:   0.032917
 Self time:   0.000642

count  total (s)   self (s)
   10   0.000162   0.000056     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
   10              0.000006     endif
                            
   10   0.031991   0.000077     let l:virtualenv = ale#python#FindVirtualenv(a:buffer)
                            
   10              0.000021     if !empty(l:virtualenv)
   20              0.000031         for l:path in a:path_list
   10   0.000232   0.000100             let l:ve_executable = ale#path#Simplify(   join([l:virtualenv, s:bin_dir, l:path], s:sep))
                            
   10              0.000112             if executable(l:ve_executable)
                                            return l:ve_executable
   10              0.000008             endif
   20              0.000024         endfor
   10              0.000007     endif
                            
   10   0.000183   0.000060     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>114_VimErrorCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:78
Called 2 times
Total time:   0.000204
 Self time:   0.000111

count  total (s)   self (s)
    2              0.000016     let l:job = ch_getjob(a:channel)
    2   0.000063   0.000032     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
    2              0.000012     if l:job_id > 0 && has_key(s:job_map, l:job_id)
    2   0.000105   0.000043         call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
    2              0.000001     endif

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:459
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000009     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    2              0.000004     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    2              0.000001     return l:timer_id

FUNCTION  <SNR>68_not_git_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 7 times
Total time:   0.002657
 Self time:   0.000342

count  total (s)   self (s)
    7   0.002651   0.000336   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>124_GroupLoclistItems()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:238
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000002     let l:grouped_items = []
    2              0.000001     let l:last_lnum = -1
                            
    3              0.000001     for l:obj in a:loclist
    1              0.000001         if l:obj.bufnr != a:buffer
                                        continue
    1              0.000000         endif
                            
                                    " Create a new sub-List when we hit a new line.
    1              0.000000         if l:obj.lnum != l:last_lnum
    1              0.000002             call add(l:grouped_items, [])
    1              0.000000         endif
                            
    1              0.000001         call add(l:grouped_items[-1], l:obj)
    1              0.000000         let l:last_lnum = l:obj.lnum
    3              0.000002     endfor
                            
    2              0.000002     return l:grouped_items

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:22
Called 12 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
   12              0.000060     if !has_key(s:buffer_data, a:buffer)
    2              0.000006         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
   12              0.000009     endif

FUNCTION  <SNR>90_is_python_string()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:364
Called 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    1              0.000003     let line = getline(a:lnum)
    1              0.000001     if a:0
    1              0.000006       let cols = type(a:1) != type([]) ? [a:1] : a:1
                                else
                                  let cols = range(1, max([1, len(line)]))
    1              0.000001     endif
    1              0.000002     for cnum in cols
    1              0.000123         if match(map(synstack(a:lnum, cnum), "synIDattr(v:val, 'name')"), 'python\S*String') == -1
    1              0.000002             return 0
                                    end
                                endfor
                                return 1

FUNCTION  <SNR>124_BuildSignMap()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:284
Called 2 times
Total time:   0.000154
 Self time:   0.000113

count  total (s)   self (s)
    2   0.000018   0.000006     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    2              0.000002     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    2              0.000003     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    2              0.000000     else
    2              0.000003         let l:selected_grouped_items = a:grouped_items
    2              0.000000     endif
                            
    2              0.000002     let l:sign_map = {}
    2              0.000002     let l:sign_offset = g:ale_sign_offset
                            
    3              0.000004     for [l:line, l:sign_id, l:name] in a:current_sign_list
    1              0.000005         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    1              0.000001         if l:sign_id > l:sign_offset
    1              0.000001             let l:sign_offset = l:sign_id
    1              0.000000         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    1              0.000002         call add(l:sign_info.current_id_list, l:sign_id)
    1              0.000001         call add(l:sign_info.current_name_list, l:name)
                            
    1              0.000002         let l:sign_map[l:line] = l:sign_info
    3              0.000002     endfor
                            
    3              0.000004     for l:group in l:selected_grouped_items
    1              0.000001         let l:line = l:group[0].lnum
    1              0.000004         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    1   0.000033   0.000004         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    1              0.000001         let l:sign_info.items = l:group
                            
    1              0.000002         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    1              0.000000         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    1              0.000000         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000002             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000001             let l:sign_offset += 1
    1              0.000000         endif
                            
    1              0.000001         let l:sign_map[l:line] = l:sign_info
    3              0.000002     endfor
                            
    2              0.000001     return l:sign_map

FUNCTION  <SNR>124_PriorityCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:156
Called 5 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    5              0.000002     if s:supports_sign_groups
    5              0.000008         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  <SNR>117_OnBlankLine()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:964
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000051   return py3eval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>112_GetVersion()
    Defined: ~/.vim/bundle/ale/autoload/ale/semver.vim:25
Called 2 times
Total time:   0.000141
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000011     let l:version = get(s:version_cache, a:executable, [])
    2   0.000110   0.000020     let l:parsed_version = ale#semver#ParseVersion(a:version_lines)
                            
    2              0.000006     if !empty(l:parsed_version)
                                    let l:version = l:parsed_version
                                    let s:version_cache[a:executable] = l:version
    2              0.000002     endif
                            
    2              0.000002     return l:version

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:49
Called 4 times
Total time:   0.000163
 Self time:   0.000049

count  total (s)   self (s)
    4   0.000146   0.000032     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    4              0.000008     let l:obj.exit_code = a:exit_code
    4              0.000006     let l:obj.status = 'finished'

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:48
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001     if a:line >= a:end_line
                                    " For single lines, just return the one position.
    1              0.000002         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 7 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    7              0.000144   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>117_OnFileReadyToParse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:731
Called 2 times
Total time:   0.002508
 Self time:   0.002273

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    2              0.000005   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    2              0.000533   if force_parsing || py3eval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
    2   0.000246   0.000022     call s:ClearSignatureHelp()
    2              0.001639     py3 ycm_state.OnFileReadyToParse()
                            
    2   0.000053   0.000042     call s:StopPoller( s:pollers.file_parse_response )
    2              0.000018     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    2              0.000002   endif

FUNCTION  <SNR>111_RunIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:527
Called 6 times
Total time:   0.023358
 Self time:   0.000389

count  total (s)   self (s)
    6   0.000077   0.000036     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    6              0.000005     endif
                            
    6   0.000653   0.000038     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    2              0.000005         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    2              0.000010         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
    2   0.002261   0.000015         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
    2              0.000003         if l:cwd isnot v:null
    2   0.000055   0.000019             call ale#command#SetCwd(a:buffer, l:cwd)
    2              0.000001         endif
                            
    2   0.013867   0.000017         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
    2              0.000004         if l:cwd isnot v:null
    2   0.000030   0.000012             call ale#command#ResetCwd(a:buffer)
    2              0.000001         endif
                            
    2              0.000023         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    2   0.006195   0.000032         return s:RunJob(l:command, l:options)
    4              0.000002     endif
                            
    4              0.000003     return 0

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:271
Called 2 times
Total time:   0.000189
 Self time:   0.000153

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    2   0.000050   0.000014     if ale#util#InSandbox()
                                    return []
    2              0.000002     endif
                            
    2              0.000005     let l:combined_linters = []
                            
    4              0.000011     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    2              0.000013         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
    2              0.000003         endif
                            
    2              0.000042         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    4              0.000007     endfor
                            
    2              0.000004     return l:combined_linters

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:432
Called 2 times
Total time:   0.002246
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000009     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
    2   0.002234   0.000020     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  <SNR>125_ShouldOpen()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:40
Called 4 times
Total time:   0.000049
 Self time:   0.000025

count  total (s)   self (s)
    4   0.000035   0.000011     let l:val = ale#Var(a:buffer, 'open_list')
    4              0.000008     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    4              0.000005     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>88_matchstrpos()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:106
Called 156 times
Total time:   0.002885
 Self time:   0.002885

count  total (s)   self (s)
  156              0.000287     if s:exists_matchstrpos
  156              0.002491         return matchstrpos(a:expr, a:pat)
                                else
                                    return [matchstr(a:expr, a:pat), match(a:expr, a:pat), matchend(a:expr, a:pat)]
                                endif

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:320
Called 2 times
Total time:   0.000207
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000191   0.000028     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    2              0.000008     if type(l:filetype) isnot v:t_list
    2              0.000004         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#semver#GTE()
    Defined: ~/.vim/bundle/ale/autoload/ale/semver.vim:62
Called 4 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    4              0.000009     if empty(a:lhs)
                                    return 0
    4              0.000003     endif
                            
    4              0.000015     if a:lhs[0] > a:rhs[0]
    2              0.000002         return 1
    2              0.000004     elseif a:lhs[0] == a:rhs[0]
    2              0.000004         if a:lhs[1] > a:rhs[1]
    2              0.000002             return 1
                                    elseif a:lhs[1] == a:rhs[1]
                                        return get(a:lhs, 2) >= get(a:rhs, 2)
                                    endif
                                endif
                            
                                return 0

FUNCTION  ale_linters#python#mypy#GetExecutable()
    Defined: ~/.vim/bundle/ale/ale_linters/python/mypy.vim:11
Called 2 times
Total time:   0.006169
 Self time:   0.000061

count  total (s)   self (s)
    2   0.000104   0.000031     if (ale#Var(a:buffer, 'python_auto_pipenv') || ale#Var(a:buffer, 'python_mypy_auto_pipenv')) && ale#python#PipenvPresent(a:buffer)
                                    return 'pipenv'
    2              0.000002     endif
                            
    2   0.006058   0.000023     return ale#python#FindExecutable(a:buffer, 'python_mypy', ['mypy'])

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:189
Called 2 times
Total time:   0.000042
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000006     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    2              0.000001     else
    2   0.000028   0.000013         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    2              0.000000     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:289
Called 16 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
   16              0.000028     try
   16              0.000183         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   16              0.000015     endtry
                            
   16              0.000014     return 0

FUNCTION  <SNR>117_OnTextChangedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:818
Called 1 time
Total time:   0.000484
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000091   0.000007   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000001   endif
                            
    1   0.000390   0.000007   call s:OnFileReadyToParse()

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:15
Called 1006 times
Total time:   0.012619
 Self time:   0.012619

count  total (s)   self (s)
 1006              0.001796     if has('unix')
 1006              0.004529         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
 1006              0.005532         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  ale#path#Upwards()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:159
Called 16 times
Total time:   0.002171
 Self time:   0.001849

count  total (s)   self (s)
   16              0.000098     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
   16              0.000042     let l:sep = has('win32') ? '\' : '/'
   16   0.000565   0.000243     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
   16              0.000022     let l:path_list = []
                            
  112              0.000202     while !empty(l:parts)
   96              0.000375         call add(l:path_list, join(l:parts, l:sep))
   96              0.000295         let l:parts = l:parts[:-2]
  112              0.000093     endwhile
                            
   16              0.000037     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
   16              0.000039     elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
   16              0.000165         call map(l:path_list, '''/'' . v:val')
   16              0.000035         call add(l:path_list, '/')
   16              0.000012     endif
                            
   16              0.000019     return l:path_list

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:203
Called 2 times
Total time:   0.002125
 Self time:   0.000117

count  total (s)   self (s)
    2              0.000011     let l:buffer_ale_root = getbufvar(   a:buffer,   'ale_root',   getbufvar(a:buffer, 'ale_lsp_root', {}))
                            
    2              0.000006     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
    2              0.000002     endif
                            
                                " Try to get a buffer-local setting for the root
    2              0.000006     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    2              0.000001     endif
                            
    2              0.000008     let l:global_root = g:ale_root
                            
    2              0.000007     if empty(g:ale_root) && exists('g:ale_lsp_root')
                                    let l:global_root = g:ale_lsp_root
    2              0.000001     endif
                            
                                " Try to get a global setting for the root
    2              0.000004     if has_key(l:global_root, a:linter.name)
                                    let l:Root = l:global_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    2              0.000001     endif
                            
                                " Fall back to the linter-specific configuration
    2              0.000004     if has_key(a:linter, 'project_root')
    2              0.000006         let l:Root = a:linter.project_root
                            
    2   0.002026   0.000018         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:83
Called 2 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    2              0.000052     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <SNR>90_find_opening_paren()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:117
Called 2 times
Total time:   0.000519
 Self time:   0.000519

count  total (s)   self (s)
                                " Return if cursor is in a comment.
    2              0.000267     if synIDattr(synID(a:lnum, a:col, 0), 'name') =~? 'comment'
                                    return [0, 0]
    2              0.000002     endif
                            
    2              0.000007     call cursor(a:lnum, a:col)
                            
    2              0.000005     let nearest = [0, 0]
    2              0.000005     let timeout = g:python_pep8_indent_searchpair_timeout
    2              0.000005     let skip_special_chars = 's:_skip_special_chars(line("."), col("."))'
    8              0.000020     for [p, maxoff] in items(s:paren_pairs)
    6              0.000033         let stopline = max([0, line('.') - maxoff, nearest[0]])
    6              0.000098         let next = searchpairpos( '\V'.p[0], '', '\V'.p[1], 'bnW', skip_special_chars, stopline, timeout)
    6              0.000021         if next[0] && (next[0] > nearest[0] || (next[0] == nearest[0] && next[1] > nearest[1]))
                                        let nearest = next
    6              0.000005         endif
    8              0.000005     endfor
    2              0.000004     return nearest

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:259
Called 2 times
Total time:   0.000347
 Self time:   0.000238

count  total (s)   self (s)
    2   0.000054   0.000012     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    2              0.000002     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    2              0.000000     endif
                            
    2              0.000002     let l:bufnr_map = {}
    2              0.000002     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    2   0.000060   0.000008     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    3              0.000002     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    1              0.000008         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    1              0.000001         if a:from_other_source
                                        let l:item.from_other_source = 1
    1              0.000000         endif
                            
    1              0.000002         if has_key(l:old_item, 'code')
    1              0.000001             let l:item.code = l:old_item.code
    1              0.000001         endif
                            
    1              0.000001         let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
    1              0.000001         if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
    1              0.000000         endif
                            
    1              0.000002         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
    1              0.000001         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
    1              0.000000         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    1              0.000001         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
    1              0.000000         endif
                            
    1              0.000002         if has_key(l:old_item, 'sub_type')
    1              0.000001             let l:item.sub_type = l:old_item.sub_type
    1              0.000000         endif
                            
    1              0.000000         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
    1              0.000002         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
    1              0.000001         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
    1              0.000002             let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
    1   0.000006   0.000004             let l:item.col = ale#util#Col(l:line, l:item.col)
                            
    1              0.000001             if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
    1              0.000001             endif
    1              0.000000         endif
                            
    1              0.000002         call add(l:new_loclist, l:item)
    3              0.000012     endfor
                            
    2   0.000021   0.000008     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    2              0.000002     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    2              0.000001     endif
                            
    2              0.000001     return l:new_loclist

FUNCTION  <SNR>117_UpdateSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1142
Called 2 times
Total time:   0.000122
 Self time:   0.000087

count  total (s)   self (s)
    2   0.000049   0.000014   if !s:ShouldUseSignatureHelp()
                                return
    2              0.000002   endif
                            
    2              0.000069   call py3eval( 'ycm_state.UpdateSignatureHelp( vim.eval( "s:signature_help" ) )' )

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:205
Called 2 times
Total time:   0.000208
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000010     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    2              0.000008     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    2   0.000018   0.000005     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    2              0.000002     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    2              0.000002     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    2   0.000164   0.000009     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>68_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 14 times
Total time:   0.004336
 Self time:   0.000636

count  total (s)   self (s)
   14   0.004327   0.000627   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:184
Called 2 times
Total time:   0.001960
 Self time:   0.000166

count  total (s)   self (s)
    2   0.000020   0.000007     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    2              0.000002     if g:ale_set_signs
    2   0.000736   0.000016         call ale#sign#SetSigns(a:buffer, a:loclist)
    2              0.000002     endif
                            
    2              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    2   0.000054   0.000012         call ale#list#SetLists(a:buffer, a:loclist)
    2              0.000000     endif
                            
    2              0.000004     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    2              0.000001     endif
                            
    2              0.000002     if g:ale_set_highlights
    2   0.000220   0.000012         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    2              0.000001     endif
                            
    2              0.000002     if l:linting_is_done
    2              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    2   0.000392   0.000009             call ale#cursor#EchoCursorWarning()
    2              0.000000         endif
                            
    2              0.000001         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    2              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    2              0.000004         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    2              0.000006         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    2   0.000412   0.000013         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    2   0.000084   0.000055         silent doautocmd <nomodeline> User ALELintPost
    2              0.000001     endif

FUNCTION  ale#semver#RunWithVersionCheck()
    Defined: ~/.vim/bundle/ale/autoload/ale/semver.vim:37
Called 4 times
Total time:   0.011898
 Self time:   0.000165

count  total (s)   self (s)
    4              0.000012     if empty(a:executable)
                                    return ''
    4              0.000002     endif
                            
    4              0.000011     let l:cache = s:version_cache
                            
    4              0.000017     if has_key(s:version_cache, a:executable)
    2   0.006923   0.000021         return a:Callback(a:buffer, s:version_cache[a:executable])
    2              0.000002     endif
                            
    2   0.004910   0.000079     return ale#command#Run(   a:buffer,   a:command,   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},   {'output_stream': 'both', 'executable': a:executable})

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 7 times
Total time:   0.023066
 Self time:   0.021938

count  total (s)   self (s)
    7   0.000734   0.000124   call gitgutter#debug#log('[async] '.a:cmd)
                            
    7              0.000070   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    7   0.000225   0.000134   let command = s:build_command(a:cmd)
                            
    7              0.000044   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    7              0.000009   else
    7              0.020133     let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    7   0.001400   0.000973     let s:jobs[s:job_id(job)] = 1
    7              0.000018   endif

FUNCTION  <SNR>111_RunJob()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:401
Called 2 times
Total time:   0.006163
 Self time:   0.000429

count  total (s)   self (s)
    2   0.000024   0.000013     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    2              0.000002     endif
                            
    2              0.000004     let l:command = a:command
                            
    2              0.000004     if empty(l:command)
                                    return 0
    2              0.000002     endif
                            
    2              0.000004     let l:cwd = a:options.cwd
    2              0.000004     let l:executable = a:options.executable
    2              0.000004     let l:buffer = a:options.buffer
    2              0.000004     let l:linter = a:options.linter
    2              0.000004     let l:output_stream = a:options.output_stream
    2              0.000005     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    2              0.000006     let l:info = g:ale_buffer_info[l:buffer]
                            
    2              0.000024     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    2   0.005625   0.000048     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    2              0.000004     if empty(l:result)
                                    return 0
    2              0.000001     endif
                            
    2   0.000084   0.000039     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    2   0.000324   0.000223     silent doautocmd <nomodeline> User ALEJobStarted
                            
    2              0.000006     return 1

FUNCTION  ale#util#GetMatches()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:324
Called 2 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    2              0.000002     let l:matches = []
    2              0.000004     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    2              0.000004     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
    3              0.000003     for l:line in l:lines
    1              0.000001         for l:pattern in l:patterns
    1              0.000051             let l:match = matchlist(l:line, l:pattern)
                            
    1              0.000002             if !empty(l:match)
    1              0.000001                 call add(l:matches, l:match)
    1              0.000001                 break
                                        endif
    1              0.000001         endfor
    3              0.000002     endfor
                            
    2              0.000002     return l:matches

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:261
Called 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000009     let l:info = get(s:buffer_data, a:buffer, {})
                            
    2              0.000005     if !empty(l:info)
    2              0.000003         let l:new_map = {}
                            
    2              0.000008         for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
    2              0.000003         endfor
                            
    2              0.000004         let l:info.jobs = l:new_map
    2              0.000002     endif

FUNCTION  <SNR>118_StopCursorTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:56
Called 9 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    9              0.000038     if s:cursor_timer != -1
    3              0.000023         call timer_stop(s:cursor_timer)
    3              0.000015         let s:cursor_timer = -1
    9              0.000015     endif

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:173
Called 2 times
Total time:   0.000054
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000003     redir => l:output
    2   0.000040   0.000030         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
    2              0.000004     redir end
                            
    2              0.000006     return split(l:output, "\n")

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:110
Called 4 times
Total time:   0.001443
 Self time:   0.000473

count  total (s)   self (s)
    4              0.000011     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    2              0.000003         return 0
    2              0.000000     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    2              0.000071     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    2              0.000009     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    2              0.000298     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    2   0.000072   0.000030     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    2   0.000946   0.000018     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    2              0.000009     return 1

FUNCTION  <SNR>127_job_id()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:104
Called 14 times
Total time:   0.000554
 Self time:   0.000554

count  total (s)   self (s)
                              " Vim
   14              0.000458   return job_info(a:job).process

FUNCTION  <lambda>1()
    Defined: ~/.vim/bundle/ale/ale_linters/python/pylint.vim:96
Called 2 times
Total time:   0.005070
 Self time:   0.000071

count  total (s)   self (s)
                            return ale#semver#RunWithVersionCheck(       buffer,       ale#Var(buffer, 'python_pylint_executable'),       '%e --version',       {buffer, version -> !ale#semver#GTE(version, [2, 4, 0])},   )

FUNCTION  <lambda>4()
    Defined: ~/.vim/bundle/ale/ale_linters/python/pyright.vim:34
Called 2 times
Total time:   0.000029
 Self time:   0.000008

count  total (s)   self (s)
                            return ale#Var(b, 'python_pyright_executable')

FUNCTION  SimpylFold#FoldExpr()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:355
Called 7 times
Total time:   0.075043
 Self time:   0.000248

count  total (s)   self (s)
    7              0.000081     if !exists('b:SimpylFold_cache')
    2   0.074911   0.000116         let b:SimpylFold_cache = s:cache()
    7              0.000005     endif
    7              0.000020     return b:SimpylFold_cache[(a:lnum)]['foldexpr']

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:108
Called 2 times
Total time:   0.002516
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    2              0.000002     if empty(l:info)
                                    return
    2              0.000001     endif
                            
    2              0.000002     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    2              0.000003         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    2              0.000002     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    2   0.000361   0.000014     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    2              0.000006     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    2              0.000003     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000002         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1              0.000002         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    2              0.000001     endif
                            
    2   0.000147   0.000007     if ale#ShouldDoNothing(a:buffer)
                                    return
    2              0.000001     endif
                            
    2   0.001967   0.000007     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>117_Complete()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1110
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                              " It's possible for us to be called (by our timer) when we're not _strictly_
                              " in insert mode. This can happen when mode is temporarily switched, e.g.
                              " due to Ctrl-r or Ctrl-o or a timer or something. If we're not in insert
                              " mode _now_ do nothing (FIXME: or should we queue a timer ?)
    2              0.000013   if count( [ 'i', 'R' ], mode() ) == 0
                                return
    2              0.000002   endif
                            
    2              0.000007   if s:completion.line != line( '.' )
                                " Given
                                "   scb: column where the completion starts before auto-wrapping
                                "   cb: cursor column before auto-wrapping
                                "   sca: column where the completion starts after auto-wrapping
                                "   ca: cursor column after auto-wrapping
                                " we have
                                "   ca - sca = cb - scb
                                "   sca = scb + ca - cb
    1              0.000004     let s:completion.completion_start_column += col( '.' ) - s:completion.column
    2              0.000001   endif
    2              0.000004   if len( s:completion.completions )
                                let old_completeopt = &completeopt
                                set completeopt+=noselect
                                call complete( s:completion.completion_start_column, s:completion.completions )
                                let &completeopt = old_completeopt
    2              0.000004   elseif pumvisible()
                                call s:CloseCompletionMenu()
    2              0.000001   endif

FUNCTION  ale#Queue()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:123
Called 2 times
Total time:   0.004149
 Self time:   0.000143

count  total (s)   self (s)
    2              0.000004     if a:0 > 2
                                    throw 'too many arguments!'
    2              0.000002     endif
                            
    2              0.000009     let l:buffer = get(a:000, 1, v:null)
                            
    2              0.000005     if l:buffer is v:null
    2              0.000007         let l:buffer = bufnr('')
    2              0.000001     endif
                            
    2              0.000007     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    2              0.000002     endif
                            
    2   0.000349   0.000014     if ale#ShouldDoNothing(l:buffer)
                                    return
    2              0.000001     endif
                            
                                " Default linting_flag to ''
    2              0.000007     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    2              0.000003     if s:lint_timer != -1
    1              0.000004         call timer_stop(s:lint_timer)
    1              0.000002         let s:lint_timer = -1
    2              0.000002     endif
                            
    2              0.000003     if a:delay > 0
    1              0.000009         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000001     else
    1   0.003690   0.000019         call s:Lint(l:buffer, l:should_lint_file, 0)
    2              0.000001     endif

FUNCTION  ale#history#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:8
Called 8 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    8              0.000052     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>125_WinFindBuf()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:80
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000009     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>90_find_start_of_multiline_statement()
    Defined: ~/.vim/bundle/vim-polyglot/indent/python.vim:140
Called 1 time
Total time:   0.000384
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000001     let lnum = a:lnum
    1              0.000001     while lnum > 0
    1              0.000004         if getline(lnum - 1) =~# '\\$'
                                        let lnum = prevnonblank(lnum - 1)
    1              0.000001         else
    1   0.000369   0.000012             let [paren_lnum, _] = s:find_opening_paren(lnum, 1)
    1              0.000001             if paren_lnum < 1
    1              0.000001                 return lnum
                                        else
                                            let lnum = paren_lnum
                                        endif
                                    endif
                                endwhile

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 7 times
Total time:   0.008388
 Self time:   0.000726

count  total (s)   self (s)
    7   0.008369   0.000707   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>79_Highlight_Matching_Pair()
    Defined: /opt/homebrew/share/vim/vim82/plugin/matchparen.vim:40
Called 6 times
Total time:   0.000815
 Self time:   0.000742

count  total (s)   self (s)
                              " Remove any previous match.
    6   0.000129   0.000056   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    6              0.000053   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    6              0.000006   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    6              0.000021   let c_lnum = line('.')
    6              0.000024   let c_col = col('.')
    6              0.000010   let before = 0
                            
    6              0.000023   let text = getline(c_lnum)
    6              0.000141   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    6              0.000021   if empty(matches)
                                let [c_before, c] = ['', '']
    6              0.000009   else
    6              0.000036     let [c_before, c] = matches[1:2]
    6              0.000008   endif
    6              0.000107   let plist = split(&matchpairs, '.\zs[:,]')
    6              0.000033   let i = index(plist, c)
    6              0.000010   if i < 0
                                " not found, in Insert mode try character before the cursor
    6              0.000027     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    6              0.000006     endif
    6              0.000008     if i < 0
                                  " not found, nothing to do
    6              0.000019       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>124_UpdateLineNumbers()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:259
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000002     let l:line_map = {}
    2              0.000002     let l:line_numbers_changed = 0
                            
    3              0.000004     for [l:line, l:sign_id, l:name] in a:current_sign_list
    1              0.000002         let l:line_map[l:sign_id] = l:line
    3              0.000001     endfor
                            
    3              0.000002     for l:item in a:loclist
    1              0.000001         if l:item.bufnr == a:buffer
    1              0.000003             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    1              0.000001             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
    1              0.000001             endif
    1              0.000000         endif
    3              0.000003     endfor
                            
                                " When the line numbers change, sort the list again
    2              0.000002     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    2              0.000000     endif

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:63
Called 6 times
Total time:   0.002537
 Self time:   0.000506

count  total (s)   self (s)
    6              0.000036     let l:buffer = bufnr('')
                            
    6              0.000013     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    6              0.000006     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    6              0.000019     if mode(1) isnot# 'n'
                                    return
    6              0.000004     endif
                            
    6   0.001089   0.000054     if ale#ShouldDoNothing(l:buffer)
                                    return
    6              0.000005     endif
                            
    6   0.000538   0.000066     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    6              0.000008     if g:ale_echo_cursor
    6              0.000012         if !empty(l:loc)
    2   0.000038   0.000011             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    2   0.000183   0.000017             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    2   0.000350   0.000019             call ale#cursor#TruncatedEcho(l:msg)
    2              0.000004             let l:info.echoed = 1
    4              0.000011         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
    1              0.000020             execute 'echo'
    1              0.000004             let l:info.echoed = 0
    6              0.000003         endif
    6              0.000005     endif
                            
    6              0.000011     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    6              0.000004     endif

FUNCTION  <SNR>111_GetLintFileSlots()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:591
Called 2 times
Total time:   0.005352
 Self time:   0.000282

count  total (s)   self (s)
    2              0.000006     let l:linter_slots = []
                            
   10              0.000029     for l:linter in a:linters
    8              0.000025         let l:LintFile = l:linter.lint_file
                            
    8              0.000028         if type(l:LintFile) is v:t_func
    2   0.005143   0.000073             let l:LintFile = l:LintFile(a:buffer)
    8              0.000010         endif
                            
    8              0.000039         call add(l:linter_slots, [l:LintFile, l:linter])
   10              0.000013     endfor
                            
    2              0.000004     return l:linter_slots

FUNCTION  270()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 7 times
Total time:   0.000510
 Self time:   0.000216

count  total (s)   self (s)
    7   0.000506   0.000212   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  <SNR>117_StopPoller()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:571
Called 14 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   14              0.000068   call timer_stop( a:poller.id )
   14              0.000049   let a:poller.id = -1

FUNCTION  <SNR>111_StopCurrentJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:449
Called 2 times
Total time:   0.000274
 Self time:   0.000209

count  total (s)   self (s)
    2              0.000070     let l:info = get(g:ale_buffer_info, a:buffer, {})
    2   0.000084   0.000019     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    2              0.000003     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
    2              0.000001     else
    2              0.000005         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
   10              0.000021         for [l:lint_file, l:linter] in a:linter_slots
    8              0.000012             if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
    8              0.000003             endif
   10              0.000009         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    2              0.000023         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    2              0.000002     endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:424
Called 8 times
Total time:   0.020373
 Self time:   0.000138

count  total (s)   self (s)
    8              0.000032     let l:Executable = a:linter.executable
                            
    8   0.020335   0.000100     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:175
Called 4 times
Total time:   0.000343
 Self time:   0.000276

count  total (s)   self (s)
    4   0.000094   0.000027     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    4              0.000026     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    4              0.000015     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
    4              0.000003     endif
                            
    4              0.000011     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    4              0.000003     endif
                            
    4              0.000036     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
    4              0.000003     endif
                            
    4              0.000073     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>117_RequestCompletion()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:969
Called 1 time
Total time:   0.000639
 Self time:   0.000534

count  total (s)   self (s)
    1   0.000015   0.000010   call s:StopPoller( s:pollers.completion )
                            
    1              0.000484   py3 ycm_state.SendCompletionRequest( vimsupport.GetBoolValue( 's:force_semantic' ) )
                            
    1              0.000023   if py3eval( 'ycm_state.CompletionRequestReady()' )
                                " We can't call complete() syncrhounsouly in the TextChangedI/TextChangedP
                                " autocommmands (it's designed to be used async only completion). The result
                                " (somewhat oddly) is that the completion menu is shown, but ctrl-n doesn't
                                " actually select anything.
                                " When the request is satisfied synchronously (e.g. the omnicompleter), we
                                " must return to the main loop before triggering completion, so we use a 0ms
                                " timer for that.
                                let s:pollers.completion.id = timer_start( 0, function( 's:PollCompletion' ) )
    1              0.000000   else
                                " Otherwise, use our usual poll timeout
    1   0.000108   0.000008     call s:PollCompletion()
    1              0.000001   endif

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:87
Called 9 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    9              0.000026     if type(a:string_or_ref) is v:t_string
    2              0.000003         return function(a:string_or_ref)
    7              0.000006     endif
                            
    7              0.000009     return a:string_or_ref

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:413
Called 2 times
Total time:   0.000127
 Self time:   0.000054

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    2   0.000057   0.000017     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    2   0.000047   0.000014     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    2              0.000018     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  <SNR>111_RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:638
Called 2 times
Total time:   0.047463
 Self time:   0.000514

count  total (s)   self (s)
    2   0.000299   0.000025     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    2   0.000120   0.000024     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    2   0.000047   0.000019     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    2   0.000242   0.000146     silent doautocmd <nomodeline> User ALELintPre
                            
   10              0.000102     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
    8              0.000017         if !l:lint_file || a:should_lint_file
    8   0.046525   0.000070             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    2              0.000005                 let l:can_clear_results = 0
    8              0.000007             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
    8              0.000006         endif
   10              0.000008     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    2              0.000004     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    2              0.000002     elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    2              0.000001     endif

FUNCTION  <SNR>116_setup_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:156
Called 7 times
Total time:   0.031478
 Self time:   0.000495

count  total (s)   self (s)
    7   0.000710   0.000139   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    7   0.030732   0.000320   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:450
Called 2 times
Total time:   0.002568
 Self time:   0.000048

count  total (s)   self (s)
    2   0.002568   0.000048     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  <SNR>117_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:511
Called 12 times
Total time:   0.002253
 Self time:   0.000298

count  total (s)   self (s)
   12   0.002217   0.000262   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 14 times
Total time:   0.000562
 Self time:   0.000562

count  total (s)   self (s)
   14              0.000163   let ggvars = getbufvar(a:buffer, 'gitgutter')
   14              0.000222   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
    7              0.000037     return ggvars[a:varname]
    7              0.000009   endif
    7              0.000013   if a:0
    7              0.000051     return a:1
                              endif

FUNCTION  <SNR>68_abs_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 35 times
Total time:   0.009114
 Self time:   0.009114

count  total (s)   self (s)
   35              0.006755   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   35              0.001964   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   35              0.000237   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:419
Called 2 times
Total time:   0.000720
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000004     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    2              0.000000     endif
                            
                                " Find the current markers
    2   0.000253   0.000009     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    2   0.000052   0.000009     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    2   0.000040   0.000008     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    2   0.000164   0.000010     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    2   0.000159   0.000011     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    2              0.000003     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    2              0.000001     endif
                            
    8              0.000007     for l:command in l:command_list
    6              0.000015         silent! execute l:command
    8              0.000002     endfor
                            
                                " Reset the sign column color when there are no more errors.
    2              0.000002     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    2              0.000000     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:104
Called 9 times
Total time:   0.001647
 Self time:   0.001337

count  total (s)   self (s)
    9              0.000146     let l:buffer = bufnr('')
                            
    9              0.000050     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    9              0.000017     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    9              0.000081     if mode(1) isnot# 'n'
                                    return
    9              0.000010     endif
                            
    9   0.000354   0.000194     call s:StopCursorTimer()
                            
    9              0.000168     let l:pos = getpos('.')[0:2]
                            
    9              0.000062     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    9              0.000012     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    9              0.000062     if l:pos != w:last_pos
    3   0.000201   0.000051         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    3              0.000029         let w:last_pos = l:pos
    3              0.000053         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    9              0.000014     endif

FUNCTION  <SNR>127_on_exit_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:87
Called 7 times
Total time:   0.000524
 Self time:   0.000397

count  total (s)   self (s)
    7              0.000046   let job = ch_getjob(a:channel)
    7   0.000188   0.000061   let jobid = s:job_id(job)
    7              0.000073   if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
    7              0.000015   while 1
    7              0.000026     if job_status(job) == 'dead'
    7              0.000055       let exit_code = job_info(job).exitval
    7              0.000011       break
                                endif
                                sleep 5m
    7              0.000015   endwhile
                            
    7              0.000012   if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    7              0.000006   endif

FUNCTION  <SNR>88_are_lines_prev_blank()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:91
Called 10 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
   10              0.000026     let lnum_prev = a:lnum - 1
   10              0.000023     while lnum_prev != 0
   10              0.000059         if !a:cache[lnum_prev]['is_blank'] && !a:cache[lnum_prev]['is_comment']
   10              0.000012             return 0
                                    endif
                                    let lnum_prev -= 1
                                endwhile
                                return 1

FUNCTION  <SNR>111_GetLintFileValues()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:607
Called 4 times
Total time:   0.048533
 Self time:   0.000881

count  total (s)   self (s)
    4              0.000009     let l:deferred_list = []
    4              0.000012     let l:new_slots = []
                            
   20              0.000075     for [l:lint_file, l:linter] in a:slots
   18   0.000245   0.000153         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
    2              0.000005             let l:lint_file = l:lint_file.value
   18              0.000021         endwhile
                            
   16   0.000189   0.000118         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
    2              0.000007             call add(l:deferred_list, l:lint_file)
   14              0.000015         else
                                        " If we have the value now, coerce it to 0 or 1.
   14              0.000034             let l:lint_file = l:lint_file is 1
   16              0.000013         endif
                            
   16              0.000067         call add(l:new_slots, [l:lint_file, l:linter])
   20              0.000029     endfor
                            
    4              0.000012     if !empty(l:deferred_list)
    4              0.000012         for l:deferred in l:deferred_list
    2              0.000020             let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
    4              0.000007         endfor
    2              0.000002     else
    2   0.047510   0.000021         call a:Callback(l:new_slots)
    4              0.000003     endif

FUNCTION  <SNR>117_InsideCommentOrStringAndShouldStop()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:950
Called 1 time
Total time:   0.000038
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000007   let retval = s:InsideCommentOrString()
    1              0.000002   let inside_comment = retval == 1
    1              0.000001   let inside_string = retval == 2
                            
    1              0.000002   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
    1              0.000000   endif
                            
    1              0.000000   return retval

FUNCTION  <SNR>88_blanks_adj()
    Defined: ~/.vim/bundle/SimpylFold/autoload/SimpylFold.vim:74
Called 140 times
Total time:   0.003681
 Self time:   0.003681

count  total (s)   self (s)
  140              0.000285     if b:SimpylFold_fold_blank
                                    return
  140              0.000124     endif
  140              0.000320     let lnum_prev = a:lnum - 1
  191              0.001484     while lnum_prev != 0 && ( a:cache[lnum_prev]['is_blank'] || ( a:cache[lnum_prev]['is_comment'] && a:cache[lnum_prev]['indent'] <= a:cache[(a:lnum)]['indent'] ) )
   51              0.000181         let a:cache[lnum_prev]['foldexpr'] = a:foldlevel
   51              0.000111         let lnum_prev -= 1
  191              0.000310     endwhile

FUNCTION  ale#util#Col()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:476
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     if a:chr < 2
    1              0.000001         return a:chr
                                endif
                            
                                return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1

FUNCTION  <SNR>117_OnTextChangedInsertMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:827
Called 1 time
Total time:   0.002236
 Self time:   0.000135

count  total (s)   self (s)
    1   0.000094   0.000009   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000000   endif
                            
    1              0.000001   if a:popup_is_visible && !s:last_char_inserted_by_user
                                " If the last "input" wasn't from a user typing (i.e. didn't come from
                                " InsertCharPre, then ignore this change in the text. This prevents ctrl-n
                                " or tab from causing us to re-filter the list based on the now-selected
                                " item.
                                return
    1              0.000001   endif
                            
    1              0.000001   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
    1              0.000001   endif
                            
    1   0.000700   0.000009   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
    1              0.000004   if s:force_semantic && !py3eval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
    1              0.000001   endif
                            
    1   0.000111   0.000022   if get( b:, 'ycm_completing' ) && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " The call to s:Complete here is necessary, to minimize flicker when we
                                " close the pum on every keypress. In that case, we try to quickly show it
                                " again with whatver the latest completion result is. When using complete(),
                                " we don't need to do this, as we only close the pum when there are no
                                " completions. However, it's still useful as we don't want Vim's filtering
                                " to _ever_ apply. Examples of when this is problematic is when typing some
                                " keys to filter (that are not a prefix of the completion), then deleting a
                                " character. Normally Vim would re-filter based on the new "query", but we
                                " don't want that.
    1   0.000041   0.000010     call s:Complete()
    1   0.000644   0.000005     call s:RequestCompletion()
                            
    1   0.000062   0.000007     call s:UpdateSignatureHelp()
    1   0.000507   0.000007     call s:RequestSignatureHelp()
    1              0.000001   endif
                            
    1              0.000032   py3 ycm_state.OnCursorMoved()
                            
    1              0.000003   if g:ycm_autoclose_preview_window_after_completion
    1   0.000019   0.000008     call s:ClosePreviewWindowIfNeeded()
    1              0.000001   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    7   0.075043   0.000248  SimpylFold#FoldExpr()
    2   0.074795   0.052077  <SNR>88_cache()
    4   0.052501   0.000213  <SNR>114_VimCloseCallback()
    4   0.052244   0.000304  <SNR>114_VimExitCallback()
    4   0.051808   0.000335  <SNR>113_ExitCallback()
    4   0.048533   0.000881  <SNR>111_GetLintFileValues()
    2   0.047463   0.000514  <SNR>111_RunLinters()
    8   0.046455   0.000205  <SNR>111_RunLinter()
    7   0.040640   0.000774  gitgutter#process_buffer()
   10   0.032917   0.000642  ale#python#FindExecutable()
   10   0.031914   0.017502  ale#python#FindVirtualenv()
    7   0.031478   0.000495  <SNR>116_setup_path()
    7   0.030412   0.001285  gitgutter#utility#set_repo_path()
    6   0.023358   0.000389  <SNR>111_RunIfExecutable()
    7   0.023066   0.021938  gitgutter#async#execute()
    6   0.021696   0.000187  ale_linters#python#flake8#GetExecutable()
    8   0.020373   0.000138  ale#linter#GetExecutable()
    6   0.019835   0.004793  <SNR>117_Hover()
    6   0.015042   0.013775  youcompleteme#GetCommandResponseAsync()
  204   0.014212   0.011327  <SNR>88_multi_string()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.074795   0.052077  <SNR>88_cache()
    7   0.023066   0.021938  gitgutter#async#execute()
   10   0.031914   0.017502  ale#python#FindVirtualenv()
    6   0.015042   0.013775  youcompleteme#GetCommandResponseAsync()
 1006              0.012619  ale#path#Simplify()
  204   0.014212   0.011327  <SNR>88_multi_string()
   35              0.009114  <SNR>68_abs_path()
    6   0.008406   0.008210  <SNR>117_PollCommand()
    4   0.005746   0.005615  ale#job#Start()
    6   0.019835   0.004793  <SNR>117_Hover()
  162              0.004649  <SNR>88_indent()
  140              0.003681  <SNR>88_blanks_adj()
    4   0.003794   0.003291  ale#python#FindProjectRootIni()
  156              0.002885  <SNR>88_matchstrpos()
    2   0.002508   0.002273  <SNR>117_OnFileReadyToParse()
  159              0.002008  ale#Var()
   16   0.002171   0.001849  ale#path#Upwards()
   12   0.001955   0.001517  <SNR>117_AllowedToCompleteInBuffer()
    9   0.001647   0.001337  ale#cursor#EchoCursorWarningWithDelay()
    7   0.030412   0.001285  gitgutter#utility#set_repo_path()

